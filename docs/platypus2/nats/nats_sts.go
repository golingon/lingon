// Copyright (c) 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package nats

import (
	"bytes"
	"fmt"

	"k8s.io/apimachinery/pkg/api/resource"

	ku "github.com/volvo-cars/lingon/pkg/kubeutil"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	natsPIDBasePath = "/var/run/nats"
	natsPIDFile     = "nats.pid"
	natsPIDPath     = natsPIDBasePath + "/" + natsPIDFile

	natsConfigBasePath = "/etc/nats-config"
	natsConfigFile     = "nats.conf"
	natsConfigPath     = natsConfigBasePath + "/" + natsConfigFile

	// RESOURCES

	ResourceCPU     = 2
	ResourceMemNum  = 4
	ResourceMemUnit = "Gi"
	ResourceJSMem   = "2G"
	ResourceStorage = "10Gi"
	storeDir        = "/data"

	// NETWORKING

	PortClient        int32 = 4222
	PortNameClient          = "client"
	PortCluster       int32 = 6222
	PortNameCluster         = "cluster"
	PortMonitor       int32 = 8222
	PortNameMonitor         = "monitor"
	PortMetrics       int32 = 7777
	PortNameMetrics         = "metrics"
	PortLeafNodes     int32 = 7422
	PortNameLeafNodes       = "leafnodes"
	PortGateways      int32 = 7522
	PortNameGateways        = "gateways"
	PortProbe               = 8222
)

var (
	d = func(i int32) string { return fmt.Sprintf("%d", i) }

	pidVolumeMount = corev1.VolumeMount{MountPath: natsPIDBasePath, Name: "pid"}

	ResourceMemory = d(ResourceMemNum) + ResourceMemUnit

	pvcName = appName + "-js-pvc"
)

func srvURLs(r int) string {
	res := bytes.Buffer{}
	for i := 0; i < r; i++ {
		u := fmt.Sprintf(
			"    nats://%s-%d.%s.%s.svc.cluster.local:%d",
			appName,
			i,
			appName,
			namespace,
			PortCluster,
		)
		res.WriteString(u)
		res.Write([]byte("\n"))
	}
	return res.String()
}

var natsConfig = map[string]string{
	natsConfigFile: `
# NATS Clients Port
port: ` + d(PortClient) + `
# PID file shared with configuration reloader.
pid_file: "` + natsPIDPath + `"
###############
#             #
# Monitoring  #
#             #
###############
http: ` + d(PortProbe) + `
server_name:$POD_NAME
server_tags: [
    "mem:` + ResourceMemory + `",
]
###################################
#                                 #
# NATS JetStream                  #
#                                 #
###################################
jetstream {
  max_mem:` + ResourceJSMem + `
  store_dir: "` + storeDir + `"
  max_file:` + ResourceStorage + `
  unique_tag: "natsuniquetag"
}
###################################
#                                 #
# NATS Full Mesh Clustering Setup #
#                                 #
###################################
cluster {
  name: natscluster
  port: ` + d(PortCluster) + `
  routes = [
` + srvURLs(replicas) + `
  ]
  cluster_advertise: $CLUSTER_ADVERTISE
  connect_retries: 120
}
lame_duck_grace_period: 10s
lame_duck_duration: 30s
`,
}

var cm = ku.ConfigAndMount{
	Data: natsConfig,
	ObjectMeta: metav1.ObjectMeta{
		Labels:    BaseLabels(),
		Name:      "nats-config",
		Namespace: namespace,
	},
	VolumeMount: corev1.VolumeMount{
		Name:      "config-volume",
		MountPath: natsConfigBasePath,
	},
}

var STS = &appsv1.StatefulSet{
	TypeMeta: ku.TypeStatefulSetV1,
	ObjectMeta: metav1.ObjectMeta{
		Labels:    ku.SetDefaultContainer(BaseLabels(), defaultContainer),
		Name:      appName,
		Namespace: namespace,
	},
	Spec: appsv1.StatefulSetSpec{
		PodManagementPolicy: appsv1.ParallelPodManagement,
		Replicas:            P(int32(replicas)),
		Selector:            &metav1.LabelSelector{MatchLabels: matchLabels},
		ServiceName:         appName,
		VolumeClaimTemplates: []corev1.PersistentVolumeClaim{
			{
				ObjectMeta: metav1.ObjectMeta{Name: pvcName},
				Spec: corev1.PersistentVolumeClaimSpec{
					AccessModes: []corev1.PersistentVolumeAccessMode{corev1.ReadWriteOnce},
					Resources: corev1.ResourceRequirements{
						Requests: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("storage"): resource.MustParse(ResourceStorage),
						},
					},
					StorageClassName: P(storageClass),
				},
			},
		},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Annotations: ku.AnnotationPrometheus(
					ku.PathMetrics,
					PortMetrics,
				),
				Labels: matchLabels,
			},

			Spec: corev1.PodSpec{
				Affinity: &corev1.Affinity{
					PodAntiAffinity: ku.AntiAffinityHostnameByLabel(
						"app", appName,
					),
				},
				Containers: []corev1.Container{
					{
						Name:  defaultContainer,
						Image: ImgNats,
						Command: []string{
							"nats-server", "--config", natsConfigPath,
						},
						ImagePullPolicy: corev1.PullIfNotPresent,

						Env: []corev1.EnvVar{
							ku.EnvVarDownAPI("POD_NAME", "metadata.name"),
							ku.EnvVarDownAPI(
								"POD_NAMESPACE",
								"metadata.namespace",
							),
							{Name: "SERVER_NAME", Value: "$(POD_NAME)"},
							{Name: "GOMEMLIMIT", Value: ResourceMemory + "B"},
							{
								Name:  "CLUSTER_ADVERTISE",
								Value: "$(POD_NAME).nats.$(POD_NAMESPACE).svc.cluster.local",
							},
							// cm.HashEnv("CONFIG_HASH_ENV"), // no need since we have the config-reloader
						},

						Lifecycle: preStop(
							"nats-server", "-sl=ldm="+natsPIDPath,
						),

						LivenessProbe:  probe,
						ReadinessProbe: probe,
						StartupProbe:   startupProbe,

						Ports: []corev1.ContainerPort{
							{
								ContainerPort: ports[PortNameClient].Port,
								Name:          ports[PortNameClient].Name,
							},
							{
								ContainerPort: ports[PortNameCluster].Port,
								Name:          ports[PortNameCluster].Name,
							},
							{
								ContainerPort: ports[PortNameMonitor].Port,
								Name:          ports[PortNameMonitor].Name,
							},
						},

						Resources: ku.Resources(
							d(ResourceCPU), ResourceMemory,
							d(ResourceCPU), ResourceMemory,
						),

						VolumeMounts: []corev1.VolumeMount{
							cm.VolumeMount,
							pidVolumeMount,
							{MountPath: storeDir, Name: pvcName}, // storage
						},
					}, {
						Name:  "reloader",
						Image: ImgConfigReloader,
						Command: []string{
							"nats-server-config-reloader",
							"-pid", natsPIDPath,
							"-config", natsConfigPath,
						},
						ImagePullPolicy: corev1.PullIfNotPresent,
						VolumeMounts: []corev1.VolumeMount{
							cm.VolumeMount,
							pidVolumeMount,
						},
					}, {
						Name:  "promexporter",
						Image: ImgPromExporter,
						Args: []string{
							// see https://github.com/nats-io/prometheus-nats-exporter/blob/main/main.go#L87
							// "-connz",               // connection metrics
							"-connz_detailed",         // advanced connection metrics
							"-jsz",                    // jetstream metrics
							"-routez",                 // route metrics
							"-subz",                   // subscription metrics
							"-varz",                   // general metrics
							"-prefix=nats",            // prefix for all metrics
							"-use_internal_server_id", // using serverID from /varz
							"http://localhost:" + d(PortMonitor) + "/",
						},
						ImagePullPolicy: corev1.PullIfNotPresent,
						Ports: []corev1.ContainerPort{
							{
								ContainerPort: PortMetrics,
								Name:          PortNameMetrics,
							},
						},
					},
				},
				DNSPolicy:                     corev1.DNSClusterFirst,
				ServiceAccountName:            SA.Name,
				ShareProcessNamespace:         P(true), // necessary for the config reloader
				TerminationGracePeriodSeconds: P(int64(60)),
				Volumes: []corev1.Volume{
					cm.VolumeAndMount().Volume(),
					{
						Name:         pidVolumeMount.Name,
						VolumeSource: corev1.VolumeSource{},
					},
				},
			},
		},
	},
}

func preStop(cmd ...string) *corev1.Lifecycle {
	return &corev1.Lifecycle{
		PreStop: &corev1.LifecycleHandler{
			Exec: &corev1.ExecAction{Command: cmd},
		},
	}
}

var probe = &corev1.Probe{
	FailureThreshold:    int32(3),
	InitialDelaySeconds: int32(10),
	PeriodSeconds:       int32(30),
	ProbeHandler:        ku.ProbeHTTP("/", PortProbe),
	SuccessThreshold:    int32(1),
	TimeoutSeconds:      int32(5),
}

var startupProbe = &corev1.Probe{
	FailureThreshold:    int32(90),
	InitialDelaySeconds: int32(10),
	PeriodSeconds:       int32(10),
	ProbeHandler:        ku.ProbeHTTP(ku.PathProbes, PortProbe),
	SuccessThreshold:    int32(1),
	TimeoutSeconds:      int32(5),
}
