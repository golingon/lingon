// Copyright 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

package terragen

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/golingon/lingon/pkg/internal/hcl"

	"github.com/hashicorp/terraform-exec/tfexec"
	tfjson "github.com/hashicorp/terraform-json"
)

// TerraformVersions ...
type TerraformVersions struct {
	TerraformBlock TerraformBlock `hcl:"terraform,block"`
}

// TerraformBlock represents a terraform{} block in a Terraform stack
type TerraformBlock struct {
	RequiredProviders RequiredProviders `hcl:"required_providers,block"`
}

// RequiredProviders represents the map of required providers for a Terraform
// stack
type RequiredProviders struct {
	Providers map[string]Provider `hcl:",remain"`
}

// Provider represents a single element of a map of required providers
type Provider struct {
	Name    string // Lack of cty tag means it is ignored
	Source  string `cty:"source"`
	Version string `cty:"version"`
}

// GenerateProviderSchema generates the schema for the given Terraform provider.
//
// The provider schema is generated by calling Terraform as follows:
//
//	terraform providers schema --json
//
// The JSON schema is then decoded and returned as a ProviderSchemas struct.
func GenerateProviderSchema(
	ctx context.Context,
	provider Provider,
) (*tfjson.ProviderSchema, error) {
	versions := TerraformVersions{
		TerraformBlock: TerraformBlock{
			RequiredProviders: RequiredProviders{
				Providers: map[string]Provider{
					provider.Name: {
						Source:  provider.Source,
						Version: provider.Version,
					},
				},
			},
		},
	}
	workingDir := filepath.Join(
		".lingon", "schemas", provider.Name,
		provider.Version,
	)
	if err := os.MkdirAll(workingDir, os.ModePerm); err != nil {
		return nil, fmt.Errorf(
			"creating schemas working directory: %s: %w",
			workingDir,
			err,
		)
	}

	// Write versions.tf file
	tfVersionsFile := filepath.Join(workingDir, "versions.tf")
	f, err := os.Create(tfVersionsFile)
	if err != nil {
		return nil, fmt.Errorf("creating file %s: %w", tfVersionsFile, err)
	}
	if err := hcl.EncodeRaw(f, versions); err != nil {
		return nil, fmt.Errorf("encoding file %s: %w", tfVersionsFile, err)
	}

	tf, err := tfexec.NewTerraform(workingDir, "terraform")
	if err != nil {
		return nil, fmt.Errorf("creating new terraform runtime: %w", err)
	}

	if err := tf.Init(ctx, tfexec.Upgrade(true)); err != nil {
		return nil, fmt.Errorf("running terraform init: %w", err)
	}

	providersSchema, err := tf.ProvidersSchema(ctx)
	if err != nil {
		return nil, fmt.Errorf("running terraform providers schema: %w", err)
	}

	return providerSchemaBySource(providersSchema, provider.Source)
}

// providerSchemaBySource returns the specific provider schema for the given
// source from the full list of provider schemas that is generated by terraform.
func providerSchemaBySource(
	schemas *tfjson.ProviderSchemas,
	source string,
) (*tfjson.ProviderSchema, error) {
	providerSchema, ok := schemas.Schemas[source]
	if !ok {
		// Try adding registry.terraform.io/ prefix if not already added
		if !strings.HasPrefix(source, "registry.terraform.io/") {
			absSource := fmt.Sprintf("registry.terraform.io/%s", source)
			providerSchema, ok = schemas.Schemas[absSource]
		}
		// If still not ok, indicate an error
		if !ok {
			return nil, fmt.Errorf(
				"provider source: %q: %w",
				source,
				ErrProviderSchemaNotFound,
			)
		}
	}
	return providerSchema, nil
}
