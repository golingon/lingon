-- out/grafana_svc.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package foopackage

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var GrafanaSVC = &corev1.Service{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "grafana",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "grafana",
			"app.kubernetes.io/version":    "9.3.6",
			"helm.sh/chart":                "grafana-6.50.7",
		},
		Name:      "grafana",
		Namespace: "monitoring",
	},
	Spec: corev1.ServiceSpec{
		Ports: []corev1.ServicePort{corev1.ServicePort{
			Name:       "service",
			Port:       int32(80),
			Protocol:   corev1.Protocol("TCP"),
			TargetPort: intstr.IntOrString{IntVal: int32(3000)},
		}},
		Selector: map[string]string{
			"app.kubernetes.io/instance": "grafana",
			"app.kubernetes.io/name":     "grafana",
		},
		Type: corev1.ServiceType("ClusterIP"),
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Service",
	},
}
-- out/app.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package foopackage

import (
	"context"
	"errors"
	kube "github.com/volvo-cars/lingon/pkg/kube"
	corev1 "k8s.io/api/core/v1"
	"os"
	"os/exec"
)

// validate the struct implements the interface
var _ kube.Exporter = (*FooApp)(nil)

// FooApp contains kubernetes manifests
type FooApp struct {
	kube.App

	GrafanaSVC *corev1.Service
}

// New creates a new FooApp
func New() *FooApp {
	return &FooApp{
		GrafanaSVC: GrafanaSVC}
}

// Apply applies the kubernetes objects to the cluster
func (a *FooApp) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *FooApp) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(km, kube.WithExportWriter(stdin)); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}
