-- out/import/tekton/cluster-role.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var AggregateEditCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":                   "default",
			"app.kubernetes.io/part-of":                    "tekton-pipelines",
			"rbac.authorization.k8s.io/aggregate-to-admin": "true",
			"rbac.authorization.k8s.io/aggregate-to-edit":  "true",
		},
		Name: "tekton-aggregate-edit",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"tasks", "taskruns", "pipelines", "pipelineruns", "pipelineresources", "runs", "customruns"},
		Verbs:     []string{"create", "delete", "deletecollection", "get", "list", "patch", "update", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}

var AggregateViewCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":                  "default",
			"app.kubernetes.io/part-of":                   "tekton-pipelines",
			"rbac.authorization.k8s.io/aggregate-to-view": "true",
		},
		Name: "tekton-aggregate-view",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"tasks", "taskruns", "pipelines", "pipelineruns", "pipelineresources", "runs", "customruns"},
		Verbs:     []string{"get", "list", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}

var PipelinesControllerClusterAccessCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-controller-cluster-access",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"pods"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"tasks", "clustertasks", "taskruns", "pipelines", "pipelineruns", "pipelineresources", "runs", "customruns"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"verificationpolicies"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"taskruns/finalizers", "pipelineruns/finalizers", "runs/finalizers", "customruns/finalizers"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"tasks/status", "clustertasks/status", "taskruns/status", "pipelines/status", "pipelineruns/status", "pipelineresources/status", "runs/status", "customruns/status", "verificationpolicies/status"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"resolution.tekton.dev"},
		Resources: []string{"resolutionrequests", "resolutionrequests/status"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}

var PipelinesControllerTenantAccessCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-controller-tenant-access",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"pods", "persistentvolumeclaims"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"events"},
		Verbs:     []string{"create", "update", "patch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"configmaps", "limitranges", "secrets", "serviceaccounts"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"apps"},
		Resources: []string{"statefulsets"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}

var PipelinesResolversResolutionRequestUpdatesCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-resolvers-resolution-request-updates",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"resolution.tekton.dev"},
		Resources: []string{"resolutionrequests", "resolutionrequests/status"},
		Verbs:     []string{"get", "list", "watch", "update", "patch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"tekton.dev"},
		Resources: []string{"tasks", "pipelines"},
		Verbs:     []string{"get", "list"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"secrets"},
		Verbs:     []string{"get", "list", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}

var PipelinesWebhookClusterAccessCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-webhook-cluster-access",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups:     []string{"apiextensions.k8s.io"},
		ResourceNames: []string{"pipelines.tekton.dev", "pipelineruns.tekton.dev", "runs.tekton.dev", "tasks.tekton.dev", "clustertasks.tekton.dev", "taskruns.tekton.dev", "pipelineresources.tekton.dev", "resolutionrequests.resolution.tekton.dev", "customruns.tekton.dev", "verificationpolicies.tekton.dev"},
		Resources:     []string{"customresourcedefinitions", "customresourcedefinitions/status"},
		Verbs:         []string{"get", "update", "patch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"apiextensions.k8s.io"},
		Resources: []string{"customresourcedefinitions"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"admissionregistration.k8s.io"},
		Resources: []string{"mutatingwebhookconfigurations", "validatingwebhookconfigurations"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"admissionregistration.k8s.io"},
		ResourceNames: []string{"webhook.pipeline.tekton.dev"},
		Resources:     []string{"mutatingwebhookconfigurations"},
		Verbs:         []string{"get", "update", "delete"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"admissionregistration.k8s.io"},
		ResourceNames: []string{"validation.webhook.pipeline.tekton.dev", "config.webhook.pipeline.tekton.dev"},
		Resources:     []string{"validatingwebhookconfigurations"},
		Verbs:         []string{"get", "update", "delete"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"tekton-pipelines"},
		Resources:     []string{"namespaces"},
		Verbs:         []string{"get"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"tekton-pipelines"},
		Resources:     []string{"namespaces/finalizers"},
		Verbs:         []string{"update"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}
-- out/import/tekton/cluster-role-binding.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var PipelinesControllerClusterAccessCRB = &rbacv1.ClusterRoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-controller-cluster-access",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "tekton-pipelines-controller-cluster-access",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRoleBinding",
	},
}

var PipelinesControllerTenantAccessCRB = &rbacv1.ClusterRoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-controller-tenant-access",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "tekton-pipelines-controller-tenant-access",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRoleBinding",
	},
}

var PipelinesResolversCRB = &rbacv1.ClusterRoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-resolvers",
		Namespace: "tekton-pipelines-resolvers",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "tekton-pipelines-resolvers-resolution-request-updates",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-resolvers",
		Namespace: "tekton-pipelines-resolvers",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRoleBinding",
	},
}

var PipelinesWebhookClusterAccessCRB = &rbacv1.ClusterRoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name: "tekton-pipelines-webhook-cluster-access",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "tekton-pipelines-webhook-cluster-access",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRoleBinding",
	},
}
-- out/import/tekton/config-map.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var BundleresolverConfigCM = &corev1.ConfigMap{
	Data: map[string]string{
		// The default layer kind in the bundle image.
		"default-kind": "task",
		// the default service account name to use for bundle requests.
		"default-service-account": "default"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "bundleresolver-config",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ClusterResolverConfigCM = &corev1.ConfigMap{
	Data: map[string]string{
		// An optional comma-separated list of namespaces which the resolver is allowed to access. Defaults to empty, meaning all namespaces are allowed.
		"allowed-namespaces": "",
		// An optional comma-separated list of namespaces which the resolver is blocked from accessing. Defaults to empty, meaning all namespaces are allowed.
		"blocked-namespaces": "",
		// The default kind to fetch.
		"default-kind": "task",
		// The default namespace to look for resources in.
		"default-namespace": ""},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "cluster-resolver-config",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigArtifactBucketCM = &corev1.ConfigMap{
	Data: nil,
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-artifact-bucket",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigArtifactPvcCM = &corev1.ConfigMap{
	Data: nil,
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-artifact-pvc",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigDefaultsCM = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n# default-timeout-minutes contains the default number of\n# minutes to use for TaskRun and PipelineRun, if none is specified.\ndefault-timeout-minutes: \"60\"  # 60 minutes\n# default-service-account contains the default service account name\n# to use for TaskRun and PipelineRun, if none is specified.\ndefault-service-account: \"default\"\n# default-managed-by-label-value contains the default value given to the\n# \"app.kubernetes.io/managed-by\" label applied to all Pods created for\n# TaskRuns. If a user's requested TaskRun specifies another value for this\n# label, the user's request supercedes.\ndefault-managed-by-label-value: \"tekton-pipelines\"\n# default-pod-template contains the default pod template to use for\n# TaskRun and PipelineRun. If a pod template is specified on the\n# PipelineRun, the default-pod-template is merged with that one.\n# default-pod-template:\n# default-affinity-assistant-pod-template contains the default pod template\n# to use for affinity assistant pods. If a pod template is specified on the\n# PipelineRun, the default-affinity-assistant-pod-template is merged with\n# that one.\n# default-affinity-assistant-pod-template:\n# default-cloud-events-sink contains the default CloudEvents sink to be\n# used for TaskRun and PipelineRun, when no sink is specified.\n# Note that right now it is still not possible to set a PipelineRun or\n# TaskRun specific sink, so the default is the only option available.\n# If no sink is specified, no CloudEvent is generated\n# default-cloud-events-sink:\n# default-task-run-workspace-binding contains the default workspace\n# configuration provided for any Workspaces that a Task declares\n# but that a TaskRun does not explicitly provide.\n# default-task-run-workspace-binding: |\n#   emptyDir: {}\n# default-max-matrix-combinations-count contains the default maximum number\n# of combinations from a Matrix, if none is specified.\ndefault-max-matrix-combinations-count: \"256\"\n# default-forbidden-env contains comma seperated environment variables that cannot be\n# overridden by podTemplate.\ndefault-forbidden-env:\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-defaults",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigLeaderElectionCM = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n# lease-duration is how long non-leaders will wait to try to acquire the\n# lock; 15 seconds is the value used by core kubernetes controllers.\nlease-duration: \"60s\"\n# renew-deadline is how long a leader will try to renew the lease before\n# giving up; 10 seconds is the value used by core kubernetes controllers.\nrenew-deadline: \"40s\"\n# retry-period is how long the leader election client waits between tries of\n# actions; 2 seconds is the value used by core kubernetes controllers.\nretry-period: \"10s\"\n# buckets is the number of buckets used to partition key space of each\n# Reconciler. If this number is M and the replica number of the controller\n# is N, the N replicas will compete for the M buckets. The owner of a\n# bucket will take care of the reconciling for the keys partitioned into\n# that bucket.\nbuckets: \"1\"\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-leader-election",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigLeaderElectionCM1 = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n# lease-duration is how long non-leaders will wait to try to acquire the\n# lock; 15 seconds is the value used by core kubernetes controllers.\nlease-duration: \"60s\"\n# renew-deadline is how long a leader will try to renew the lease before\n# giving up; 10 seconds is the value used by core kubernetes controllers.\nrenew-deadline: \"40s\"\n# retry-period is how long the leader election client waits between tries of\n# actions; 2 seconds is the value used by core kubernetes controllers.\nretry-period: \"10s\"\n# buckets is the number of buckets used to partition key space of each\n# Reconciler. If this number is M and the replica number of the controller\n# is N, the N replicas will compete for the M buckets. The owner of a\n# bucket will take care of the reconciling for the keys partitioned into\n# that bucket.\nbuckets: \"1\"\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "config-leader-election",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigLoggingCM = &corev1.ConfigMap{
	Data: map[string]string{
		// Log level overrides
		"loglevel.controller": "info",
		"loglevel.webhook":    "info",
		"zap-logger-config": `
{
  "level": "info",
  "development": false,
  "sampling": {
    "initial": 100,
    "thereafter": 100
  },
  "outputPaths": ["stdout"],
  "errorOutputPaths": ["stderr"],
  "encoding": "json",
  "encoderConfig": {
    "timeKey": "timestamp",
    "levelKey": "severity",
    "nameKey": "logger",
    "callerKey": "caller",
    "messageKey": "message",
    "stacktraceKey": "stacktrace",
    "lineEnding": "",
    "levelEncoder": "",
    "timeEncoder": "iso8601",
    "durationEncoder": "",
    "callerEncoder": ""
  }
}

`},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-logging",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigLoggingCM2 = &corev1.ConfigMap{
	Data: map[string]string{
		// Log level overrides
		"loglevel.controller": "info",
		"loglevel.webhook":    "info",
		"zap-logger-config": `
{
  "level": "info",
  "development": false,
  "sampling": {
    "initial": 100,
    "thereafter": 100
  },
  "outputPaths": ["stdout"],
  "errorOutputPaths": ["stderr"],
  "encoding": "json",
  "encoderConfig": {
    "timeKey": "timestamp",
    "levelKey": "severity",
    "nameKey": "logger",
    "callerKey": "caller",
    "messageKey": "message",
    "stacktraceKey": "stacktrace",
    "lineEnding": "",
    "levelEncoder": "",
    "timeEncoder": "iso8601",
    "durationEncoder": "",
    "callerEncoder": ""
  }
}

`},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "config-logging",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigObservabilityCM = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n# metrics.backend-destination field specifies the system metrics destination.\n# It supports either prometheus (the default) or stackdriver.\n# Note: Using Stackdriver will incur additional charges.\nmetrics.backend-destination: prometheus\n# metrics.stackdriver-project-id field specifies the Stackdriver project ID. This\n# field is optional. When running on GCE, application default credentials will be\n# used and metrics will be sent to the cluster's project if this field is\n# not provided.\nmetrics.stackdriver-project-id: \"<your stackdriver project id>\"\n# metrics.allow-stackdriver-custom-metrics indicates whether it is allowed\n# to send metrics to Stackdriver using \"global\" resource type and custom\n# metric type. Setting this flag to \"true\" could cause extra Stackdriver\n# charge.  If metrics.backend-destination is not Stackdriver, this is\n# ignored.\nmetrics.allow-stackdriver-custom-metrics: \"false\"\nmetrics.taskrun.level: \"task\"\nmetrics.taskrun.duration-type: \"histogram\"\nmetrics.pipelinerun.level: \"pipeline\"\nmetrics.pipelinerun.duration-type: \"histogram\"\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-observability",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigObservabilityCM3 = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n# metrics.backend-destination field specifies the system metrics destination.\n# It supports either prometheus (the default) or stackdriver.\n# Note: Using stackdriver will incur additional charges\nmetrics.backend-destination: prometheus\n# metrics.request-metrics-backend-destination specifies the request metrics\n# destination. If non-empty, it enables queue proxy to send request metrics.\n# Currently supported values: prometheus, stackdriver.\nmetrics.request-metrics-backend-destination: prometheus\n# metrics.stackdriver-project-id field specifies the stackdriver project ID. This\n# field is optional. When running on GCE, application default credentials will be\n# used if this field is not provided.\nmetrics.stackdriver-project-id: \"<your stackdriver project id>\"\n# metrics.allow-stackdriver-custom-metrics indicates whether it is allowed to send metrics to\n# Stackdriver using \"global\" resource type and custom metric type if the\n# metrics are not supported by \"knative_revision\" resource type. Setting this\n# flag to \"true\" could cause extra Stackdriver charge.\n# If metrics.backend-destination is not Stackdriver, this is ignored.\nmetrics.allow-stackdriver-custom-metrics: \"false\"\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "config-observability",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigRegistryCertCM = &corev1.ConfigMap{
	Data: nil,
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-registry-cert",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigSpireCM = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n#\n# spire-trust-domain specifies the SPIRE trust domain to use.\n# spire-trust-domain: \"example.org\"\n#\n# spire-socket-path specifies the SPIRE agent socket for SPIFFE workload API.\n# spire-socket-path: \"unix:///spiffe-workload-api/spire-agent.sock\"\n#\n# spire-server-addr specifies the SPIRE server address for workload/node registration.\n# spire-server-addr: \"spire-server.spire.svc.cluster.local:8081\"\n#\n# spire-node-alias-prefix specifies the SPIRE node alias prefix to use.\n# spire-node-alias-prefix: \"/tekton-node/\"\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-spire",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ConfigTrustedResourcesCM = &corev1.ConfigMap{
	Data: map[string]string{
		"_example": "################################\n#                              #\n#    EXAMPLE CONFIGURATION     #\n#                              #\n################################\n# This block is not actually functional configuration,\n# but serves to illustrate the available configuration\n# options and document them in a way that is accessible\n# to users that `kubectl edit` this config map.\n#\n# These sample configuration options may be copied out of\n# this example block and unindented to be in the data block\n# to actually change the configuration.\n# publickeys specifies the list of public keys, the paths are separated by comma\n# publickeys: \"/etc/verification-secrets/cosign.pub,\n# gcpkms://projects/tekton/locations/us/keyRings/trusted-resources/cryptoKeys/trusted-resources\"\n"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "config-trusted-resources",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var FeatureFlagsCM = &corev1.ConfigMap{
	Data: map[string]string{
		/*
		   Setting this flag to "false" will stop Tekton from waiting for a
		   TaskRun's sidecar containers to be running before starting the first
		   step. This will allow Tasks to be run in environments that don't
		   support the DownwardAPI volume type, but may lead to unintended
		   behaviour if sidecars are used.
		   #
		   See https://github.com/tektoncd/pipeline/issues/4937 for more info.
		*/
		"await-sidecar-readiness": "true",
		/*
		   Setting this flag will determine the version for custom tasks created by PipelineRuns.
		   Acceptable values are "v1beta1" and "v1alpha1".
		   The default is "v1beta1".
		*/
		"custom-task-version": "v1beta1",
		/*
		   Setting this flag to "true" will prevent Tekton to create an
		   Affinity Assistant for every TaskRun sharing a PVC workspace
		   #
		   The default behaviour is for Tekton to create Affinity Assistants
		   #
		   See more in the workspace documentation about Affinity Assistant
		   https://github.com/tektoncd/pipeline/blob/main/docs/workspaces.md#affinity-assistant-and-specifying-workspace-order-in-a-pipeline
		   or https://github.com/tektoncd/pipeline/pull/2630 for more info.
		*/
		"disable-affinity-assistant": "false",
		/*
		   Setting this flag to "true" will prevent Tekton scanning attached
		   service accounts and injecting any credentials it finds into your
		   Steps.
		   #
		   The default behaviour currently is for Tekton to search service
		   accounts for secrets matching a specified format and automatically
		   mount those into your Steps.
		   #
		   Note: setting this to "true" will prevent PipelineResources from
		   working.
		   #
		   See https://github.com/tektoncd/pipeline/issues/2791 for more
		   info.
		*/
		"disable-creds-init": "false",
		/*
		   Setting this flag will determine which gated features are enabled.
		   Acceptable values are "stable", "beta", or "alpha".
		*/
		"enable-api-fields": "stable",
		/*
		   Setting this flag to "true" enables populating the "provenance" field in TaskRun
		   and PipelineRun status. This field contains metadata about resources used
		   in the TaskRun/PipelineRun such as the source from where a remote Task/Pipeline
		   definition was fetched.
		*/
		"enable-provenance-in-status": "false",
		/*
		   Setting this flag to "true" enables the use of Tekton OCI bundle.
		   This is an experimental feature and thus should still be considered
		   an alpha feature.
		*/
		"enable-tekton-oci-bundles": "false",
		/*
		   Setting this flag will determine how Tekton pipelines will handle non-falsifiable provenance.
		   If set to "spire", then SPIRE will be used to ensure non-falsifiable provenance.
		   If set to "none", then Tekton will not have non-falsifiable provenance.
		   This is an experimental feature and thus should still be considered an alpha feature.
		*/
		"enforce-nonfalsifiablity": "none",
		/*
		   Setting this flag to "true" will require that any Git SSH Secret
		   offered to Tekton must have known_hosts included.
		   #
		   See https://github.com/tektoncd/pipeline/issues/2981 for more
		   info.
		*/
		"require-git-ssh-secret-known-hosts": "false",
		/*
		   Setting this flag to "enforce" will enforce verification of tasks/pipeline. Failing to verify
		   will fail the taskrun/pipelinerun. "warn" will only log the err message and "skip"
		   will skip the whole verification
		*/
		"resource-verification-mode": "skip",
		/*
		   This option should be set to false when Pipelines is running in a
		   cluster that does not use injected sidecars such as Istio. Setting
		   it to false should decrease the time it takes for a TaskRun to start
		   running. For clusters that use injected sidecars, setting this
		   option to false can lead to unexpected behavior.
		   #
		   See https://github.com/tektoncd/pipeline/issues/2080 for more info.
		*/
		"running-in-environment-with-injected-sidecars": "true",
		/*
		   Setting this flag to "true" enables CloudEvents for CustomRuns and Runs, as long as a
		   CloudEvents sink is configured in the config-defaults config map
		*/
		"send-cloudevents-for-runs": "false"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "feature-flags",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var GitResolverConfigCM = &corev1.ConfigMap{
	Data: map[string]string{
		// The key in the API token secret containing the actual token. Required when using the authenticated API.
		"api-token-secret-key": "",
		// The Kubernetes secret containing the API token for the SCM provider. Required when using the authenticated API.
		"api-token-secret-name": "",
		// The namespace containing the API token secret. Defaults to "default".
		"api-token-secret-namespace": "default",
		/*
		   The default organization to look for repositories under when using the authenticated API,
		   if not specified in the resolver parameters. Optional.
		*/
		"default-org": "",
		// The git revision to fetch the remote resource from with either anonymous cloning or the authenticated API.
		"default-revision": "main",
		// The git url to fetch the remote resource from when using anonymous cloning.
		"default-url": "https://github.com/tektoncd/catalog.git",
		// The maximum amount of time a single anonymous cloning resolution may take.
		"fetch-timeout": "1m",
		// The SCM type to use with the authenticated API. Can be github, gitlab, gitea, bitbucketserver, bitbucketcloud
		"scm-type": "github",
		// The SCM server URL to use with the authenticated API. Not needed when using github.com, gitlab.com, or BitBucket Cloud
		"server-url": ""},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "git-resolver-config",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var HubresolverConfigCM = &corev1.ConfigMap{
	Data: map[string]string{
		// the default Artifact Hub Pipeline catalog from where to pull the resource.
		"default-artifact-hub-pipeline-catalog": "tekton-catalog-pipelines",
		// the default Artifact Hub Task catalog from where to pull the resource.
		"default-artifact-hub-task-catalog": "tekton-catalog-tasks",
		// the default layer kind in the hub image.
		"default-kind": "task",
		// the default Tekton Hub catalog from where to pull the resource.
		"default-tekton-hub-catalog": "Tekton",
		// the default hub source to pull the resource from.
		"default-type": "artifact"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "hubresolver-config",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var PipelinesInfoCM = &corev1.ConfigMap{
	Data: map[string]string{
		/*
		   Contains pipelines version which can be queried by external
		   tools such as CLI. Elevated permissions are already given to
		   this ConfigMap such that even if we don't have access to
		   other resources in the namespace we still can have access to
		   this ConfigMap.
		*/
		"version": "v0.45.0"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "pipelines-info",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}

var ResolversFeatureFlagsCM = &corev1.ConfigMap{
	Data: map[string]string{
		// Setting this flag to "true" enables remote resolution of Tekton OCI bundles.
		"enable-bundles-resolver": "true",
		// Setting this flag to "true" enables remote resolution of tasks and pipelines from other namespaces within the cluster.
		"enable-cluster-resolver": "true",
		// Setting this flag to "true" enables remote resolution of tasks and pipelines from Git repositories.
		"enable-git-resolver": "true",
		// Setting this flag to "true" enables remote resolution of tasks and pipelines via the Tekton Hub.
		"enable-hub-resolver": "true"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "resolvers-feature-flags",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}
-- out/import/tekton/custom-resource-definition.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var ClustertasksDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "clustertasks.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Conversion: &apiextensionsv1.CustomResourceConversion{
			Strategy: apiextensionsv1.ConversionStrategyType("Webhook"),
			Webhook: &apiextensionsv1.WebhookConversion{
				ClientConfig: &apiextensionsv1.WebhookClientConfig{Service: &apiextensionsv1.ServiceReference{
					Name:      "tekton-pipelines-webhook",
					Namespace: "tekton-pipelines",
				}},
				ConversionReviewVersions: []string{"v1beta1"},
			},
		},
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "ClusterTask",
			Plural:     "clustertasks",
			Singular:   "clustertask",
		},
		Scope: apiextensionsv1.ResourceScope("Cluster"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var CustomrunsDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "customruns.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "CustomRun",
			Plural:     "customruns",
			Singular:   "customrun",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].status`,
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].reason`,
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.startTime",
				Name:     "StartTime",
				Type:     "date",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.completionTime",
				Name:     "CompletionTime",
				Type:     "date",
			}},
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var PipelineresourcesDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "pipelineresources.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "PipelineResource",
			Plural:     "pipelineresources",
			Singular:   "pipelineresource",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1alpha1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var PipelinerunsDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "pipelineruns.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Conversion: &apiextensionsv1.CustomResourceConversion{
			Strategy: apiextensionsv1.ConversionStrategyType("Webhook"),
			Webhook: &apiextensionsv1.WebhookConversion{
				ClientConfig: &apiextensionsv1.WebhookClientConfig{Service: &apiextensionsv1.ServiceReference{
					Name:      "tekton-pipelines-webhook",
					Namespace: "tekton-pipelines",
				}},
				ConversionReviewVersions: []string{"v1beta1", "v1"},
			},
		},
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "PipelineRun",
			Plural:     "pipelineruns",
			ShortNames: []string{"pr", "prs"},
			Singular:   "pipelinerun",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].status`,
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].reason`,
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.startTime",
				Name:     "StartTime",
				Type:     "date",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.completionTime",
				Name:     "CompletionTime",
				Type:     "date",
			}},
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}, apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].status`,
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].reason`,
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.startTime",
				Name:     "StartTime",
				Type:     "date",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.completionTime",
				Name:     "CompletionTime",
				Type:     "date",
			}},
			Name: "v1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var PipelinesDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "pipelines.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Conversion: &apiextensionsv1.CustomResourceConversion{
			Strategy: apiextensionsv1.ConversionStrategyType("Webhook"),
			Webhook: &apiextensionsv1.WebhookConversion{
				ClientConfig: &apiextensionsv1.WebhookClientConfig{Service: &apiextensionsv1.ServiceReference{
					Name:      "tekton-pipelines-webhook",
					Namespace: "tekton-pipelines",
				}},
				ConversionReviewVersions: []string{"v1beta1", "v1"},
			},
		},
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "Pipeline",
			Plural:     "pipelines",
			Singular:   "pipeline",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}, apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var ResolutionrequestsResolutionDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{"resolution.tekton.dev/release": "devel"},
		Name:   "resolutionrequests.resolution.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Conversion: &apiextensionsv1.CustomResourceConversion{
			Strategy: apiextensionsv1.ConversionStrategyType("Webhook"),
			Webhook: &apiextensionsv1.WebhookConversion{
				ClientConfig: &apiextensionsv1.WebhookClientConfig{Service: &apiextensionsv1.ServiceReference{
					Name:      "tekton-pipelines-webhook",
					Namespace: "tekton-pipelines",
				}},
				ConversionReviewVersions: []string{"v1alpha1", "v1beta1"},
			},
		},
		Group: "resolution.tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "ResolutionRequest",
			Plural:     "resolutionrequests",
			ShortNames: []string{"resolutionrequest", "resolutionrequests"},
			Singular:   "resolutionrequest",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.conditions[?(@.type=='Succeeded')].status",
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.conditions[?(@.type=='Succeeded')].reason",
				Name:     "Reason",
				Type:     "string",
			}},
			Deprecated: true,
			Name:       "v1alpha1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}, apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".metadata.ownerReferences[0].kind",
				Name:     "OwnerKind",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".metadata.ownerReferences[0].name",
				Name:     "Owner",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.conditions[?(@.type=='Succeeded')].status",
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.conditions[?(@.type=='Succeeded')].reason",
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".metadata.creationTimestamp",
				Name:     "StartTime",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.conditions[?(@.type=='Succeeded')].lastTransitionTime",
				Name:     "EndTime",
				Type:     "string",
			}},
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var RunsDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "runs.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "Run",
			Plural:     "runs",
			Singular:   "run",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].status`,
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].reason`,
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.startTime",
				Name:     "StartTime",
				Type:     "date",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.completionTime",
				Name:     "CompletionTime",
				Type:     "date",
			}},
			Name: "v1alpha1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var TaskrunsDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "taskruns.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Conversion: &apiextensionsv1.CustomResourceConversion{
			Strategy: apiextensionsv1.ConversionStrategyType("Webhook"),
			Webhook: &apiextensionsv1.WebhookConversion{
				ClientConfig: &apiextensionsv1.WebhookClientConfig{Service: &apiextensionsv1.ServiceReference{
					Name:      "tekton-pipelines-webhook",
					Namespace: "tekton-pipelines",
				}},
				ConversionReviewVersions: []string{"v1beta1", "v1"},
			},
		},
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "TaskRun",
			Plural:     "taskruns",
			ShortNames: []string{"tr", "trs"},
			Singular:   "taskrun",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].status`,
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].reason`,
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.startTime",
				Name:     "StartTime",
				Type:     "date",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.completionTime",
				Name:     "CompletionTime",
				Type:     "date",
			}},
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}, apiextensionsv1.CustomResourceDefinitionVersion{
			AdditionalPrinterColumns: []apiextensionsv1.CustomResourceColumnDefinition{apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].status`,
				Name:     "Succeeded",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: `.status.conditions[?(@.type=="Succeeded")].reason`,
				Name:     "Reason",
				Type:     "string",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.startTime",
				Name:     "StartTime",
				Type:     "date",
			}, apiextensionsv1.CustomResourceColumnDefinition{
				JSONPath: ".status.completionTime",
				Name:     "CompletionTime",
				Type:     "date",
			}},
			Name: "v1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var TasksDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "tasks.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Conversion: &apiextensionsv1.CustomResourceConversion{
			Strategy: apiextensionsv1.ConversionStrategyType("Webhook"),
			Webhook: &apiextensionsv1.WebhookConversion{
				ClientConfig: &apiextensionsv1.WebhookClientConfig{Service: &apiextensionsv1.ServiceReference{
					Name:      "tekton-pipelines-webhook",
					Namespace: "tekton-pipelines",
				}},
				ConversionReviewVersions: []string{"v1beta1", "v1"},
			},
		},
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "Task",
			Plural:     "tasks",
			Singular:   "task",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1beta1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Storage:      true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}, apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:       true,
			Subresources: &apiextensionsv1.CustomResourceSubresources{},
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}

var VerificationpoliciesDevCRD = &apiextensionsv1.CustomResourceDefinition{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name: "verificationpolicies.tekton.dev",
	},
	Spec: apiextensionsv1.CustomResourceDefinitionSpec{
		Group: "tekton.dev",
		Names: apiextensionsv1.CustomResourceDefinitionNames{
			Categories: []string{"tekton", "tekton-pipelines"},
			Kind:       "VerificationPolicy",
			Plural:     "verificationpolicies",
			Singular:   "verificationpolicy",
		},
		Scope: apiextensionsv1.ResourceScope("Namespaced"),
		Versions: []apiextensionsv1.CustomResourceDefinitionVersion{apiextensionsv1.CustomResourceDefinitionVersion{
			Name: "v1alpha1",
			Schema: &apiextensionsv1.CustomResourceValidation{OpenAPIV3Schema: &apiextensionsv1.JSONSchemaProps{
				Type:                   "object",
				XPreserveUnknownFields: P(true),
			}},
			Served:  true,
			Storage: true,
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apiextensions.k8s.io/v1",
		Kind:       "CustomResourceDefinition",
	},
}
-- out/import/tekton/deployment.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var PipelinesControllerDeploy = &appsv1.Deployment{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "controller",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"app.kubernetes.io/version":   "v0.45.0",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	},
	Spec: appsv1.DeploymentSpec{
		Replicas: P(int32(1)),
		Selector: &metav1.LabelSelector{MatchLabels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "controller",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		}},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{
				"app":                         "tekton-pipelines-controller",
				"app.kubernetes.io/component": "controller",
				"app.kubernetes.io/instance":  "default",
				"app.kubernetes.io/name":      "controller",
				"app.kubernetes.io/part-of":   "tekton-pipelines",
				"app.kubernetes.io/version":   "v0.45.0",
				"pipeline.tekton.dev/release": "v0.45.0",
				"version":                     "v0.45.0",
			}},
			Spec: corev1.PodSpec{
				Affinity: &corev1.Affinity{NodeAffinity: &corev1.NodeAffinity{RequiredDuringSchedulingIgnoredDuringExecution: &corev1.NodeSelector{NodeSelectorTerms: []corev1.NodeSelectorTerm{corev1.NodeSelectorTerm{MatchExpressions: []corev1.NodeSelectorRequirement{corev1.NodeSelectorRequirement{
					Key:      "kubernetes.io/os",
					Operator: corev1.NodeSelectorOperator("NotIn"),
					Values:   []string{"windows"},
				}}}}}}},
				Containers: []corev1.Container{corev1.Container{
					Args: []string{"-git-image", "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.45.0@sha256:8ab0f58d8381b0b71f5b2bae1f63522989d739e3154d8cab1bacfa0ef5317214", "-entrypoint-image", "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/entrypoint:v0.45.0@sha256:9e1ed138383b2266a7916cd3a501fb50335da36d4fd72fd0a4de2aac142cf4b4", "-nop-image", "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/nop:v0.45.0@sha256:3314b1f7222c41ab6e191bb4d4e13b519cc1c2f71f66e29ce86d9eaf611808f0", "-sidecarlogresults-image", "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/sidecarlogresults:v0.45.0@sha256:3e2d834c4820f06c44a79362d17b847bb0f108a385a932e5f5fdb32160b38b3a", "-imagedigest-exporter-image", "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/imagedigestexporter:v0.45.0@sha256:80d09ba9f2aa293a0d4b93ff44a56d6cbeb7669cf4108b63d8a3a94c0b446509", "-workingdirinit-image", "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/workingdirinit:v0.45.0@sha256:52fe1b196c2f473cde962745768787ad48b9fd15544a5d2c69bd40c2ade0a461", "-gsutil-image", "gcr.io/google.com/cloudsdktool/cloud-sdk@sha256:27b2c22bf259d9bc1a291e99c63791ba0c27a04d2db0a43241ba0f1f20f4067f", "-shell-image", "cgr.dev/chainguard/busybox@sha256:19f02276bf8dbdd62f069b922f10c65262cc34b710eea26ff928129a736be791", "-shell-image-win", "mcr.microsoft.com/powershell:nanoserver@sha256:b6d5ff841b78bdf2dfed7550000fd4f3437385b8fa686ec0f010be24777654d6"},
					Env: []corev1.EnvVar{corev1.EnvVar{
						Name:      "SYSTEM_NAMESPACE",
						ValueFrom: &corev1.EnvVarSource{FieldRef: &corev1.ObjectFieldSelector{FieldPath: "metadata.namespace"}},
					}, corev1.EnvVar{
						Name:  "CONFIG_DEFAULTS_NAME",
						Value: "config-defaults",
					}, corev1.EnvVar{
						Name:  "CONFIG_LOGGING_NAME",
						Value: "config-logging",
					}, corev1.EnvVar{
						Name:  "CONFIG_OBSERVABILITY_NAME",
						Value: "config-observability",
					}, corev1.EnvVar{
						Name:  "CONFIG_ARTIFACT_BUCKET_NAME",
						Value: "config-artifact-bucket",
					}, corev1.EnvVar{
						Name:  "CONFIG_ARTIFACT_PVC_NAME",
						Value: "config-artifact-pvc",
					}, corev1.EnvVar{
						Name:  "CONFIG_FEATURE_FLAGS_NAME",
						Value: "feature-flags",
					}, corev1.EnvVar{
						Name:  "CONFIG_LEADERELECTION_NAME",
						Value: "config-leader-election",
					}, corev1.EnvVar{
						Name:  "CONFIG_SPIRE",
						Value: "config-spire",
					}, corev1.EnvVar{
						Name:  "CONFIG_TRUSTED_RESOURCES_NAME",
						Value: "config-trusted-resources",
					}, corev1.EnvVar{
						Name:  "SSL_CERT_FILE",
						Value: "/etc/config-registry-cert/cert",
					}, corev1.EnvVar{
						Name:  "SSL_CERT_DIR",
						Value: "/etc/ssl/certs",
					}, corev1.EnvVar{
						Name:  "METRICS_DOMAIN",
						Value: "tekton.dev/pipeline",
					}},
					Image: "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/controller:v0.45.0@sha256:8a302dab54484bbb83d46ff9455b077ea51c1c189641dcda12575f8301bfb257",
					LivenessProbe: &corev1.Probe{
						InitialDelaySeconds: int32(5),
						PeriodSeconds:       int32(10),
						ProbeHandler: corev1.ProbeHandler{HTTPGet: &corev1.HTTPGetAction{
							Path: "/health",
							Port: intstr.IntOrString{
								StrVal: "probes",
								Type:   intstr.Type(int64(1)),
							},
							Scheme: corev1.URIScheme("HTTP"),
						}},
						TimeoutSeconds: int32(5),
					},
					Name: "tekton-pipelines-controller",
					Ports: []corev1.ContainerPort{corev1.ContainerPort{
						ContainerPort: int32(9090),
						Name:          "metrics",
					}, corev1.ContainerPort{
						ContainerPort: int32(8008),
						Name:          "profiling",
					}, corev1.ContainerPort{
						ContainerPort: int32(8080),
						Name:          "probes",
					}},
					ReadinessProbe: &corev1.Probe{
						InitialDelaySeconds: int32(5),
						PeriodSeconds:       int32(10),
						ProbeHandler: corev1.ProbeHandler{HTTPGet: &corev1.HTTPGetAction{
							Path: "/readiness",
							Port: intstr.IntOrString{
								StrVal: "probes",
								Type:   intstr.Type(int64(1)),
							},
							Scheme: corev1.URIScheme("HTTP"),
						}},
						TimeoutSeconds: int32(5),
					},
					SecurityContext: &corev1.SecurityContext{
						Capabilities:   &corev1.Capabilities{Drop: []corev1.Capability{corev1.Capability("ALL")}},
						RunAsGroup:     P(int64(65532)),
						RunAsNonRoot:   P(true),
						RunAsUser:      P(int64(65532)),
						SeccompProfile: &corev1.SeccompProfile{Type: corev1.SeccompProfileType("RuntimeDefault")},
					},
					VolumeMounts: []corev1.VolumeMount{corev1.VolumeMount{
						MountPath: "/etc/config-logging",
						Name:      "config-logging",
					}, corev1.VolumeMount{
						MountPath: "/etc/config-registry-cert",
						Name:      "config-registry-cert",
					}, corev1.VolumeMount{
						MountPath: "/etc/verification-secrets",
						Name:      "verification-secrets",
						ReadOnly:  true,
					}},
				}},
				ServiceAccountName: "tekton-pipelines-controller",
				Volumes: []corev1.Volume{corev1.Volume{
					Name:         "config-logging",
					VolumeSource: corev1.VolumeSource{ConfigMap: &corev1.ConfigMapVolumeSource{LocalObjectReference: corev1.LocalObjectReference{Name: "config-logging"}}},
				}, corev1.Volume{
					Name:         "config-registry-cert",
					VolumeSource: corev1.VolumeSource{ConfigMap: &corev1.ConfigMapVolumeSource{LocalObjectReference: corev1.LocalObjectReference{Name: "config-registry-cert"}}},
				}, corev1.Volume{
					Name: "verification-secrets",
					VolumeSource: corev1.VolumeSource{Secret: &corev1.SecretVolumeSource{
						Optional:   P(true),
						SecretName: "verification-secrets",
					}},
				}},
			},
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apps/v1",
		Kind:       "Deployment",
	},
}

var PipelinesRemoteResolversDeploy = &appsv1.Deployment{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "resolvers",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"app.kubernetes.io/version":   "v0.45.0",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name:      "tekton-pipelines-remote-resolvers",
		Namespace: "tekton-pipelines-resolvers",
	},
	Spec: appsv1.DeploymentSpec{
		Replicas: P(int32(1)),
		Selector: &metav1.LabelSelector{MatchLabels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "resolvers",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		}},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{
				"app":                         "tekton-pipelines-resolvers",
				"app.kubernetes.io/component": "resolvers",
				"app.kubernetes.io/instance":  "default",
				"app.kubernetes.io/name":      "resolvers",
				"app.kubernetes.io/part-of":   "tekton-pipelines",
				"app.kubernetes.io/version":   "v0.45.0",
				"pipeline.tekton.dev/release": "v0.45.0",
				"version":                     "v0.45.0",
			}},
			Spec: corev1.PodSpec{
				Affinity: &corev1.Affinity{PodAntiAffinity: &corev1.PodAntiAffinity{PreferredDuringSchedulingIgnoredDuringExecution: []corev1.WeightedPodAffinityTerm{corev1.WeightedPodAffinityTerm{
					PodAffinityTerm: corev1.PodAffinityTerm{
						LabelSelector: &metav1.LabelSelector{MatchLabels: map[string]string{
							"app.kubernetes.io/component": "resolvers",
							"app.kubernetes.io/instance":  "default",
							"app.kubernetes.io/name":      "resolvers",
							"app.kubernetes.io/part-of":   "tekton-pipelines",
						}},
						TopologyKey: "kubernetes.io/hostname",
					},
					Weight: int32(100),
				}}}},
				Containers: []corev1.Container{corev1.Container{
					Env: []corev1.EnvVar{corev1.EnvVar{
						Name:      "SYSTEM_NAMESPACE",
						ValueFrom: &corev1.EnvVarSource{FieldRef: &corev1.ObjectFieldSelector{FieldPath: "metadata.namespace"}},
					}, corev1.EnvVar{
						Name:  "CONFIG_LOGGING_NAME",
						Value: "config-logging",
					}, corev1.EnvVar{
						Name:  "CONFIG_OBSERVABILITY_NAME",
						Value: "config-observability",
					}, corev1.EnvVar{
						Name:  "CONFIG_FEATURE_FLAGS_NAME",
						Value: "feature-flags",
					}, corev1.EnvVar{
						Name:  "CONFIG_LEADERELECTION_NAME",
						Value: "config-leader-election",
					}, corev1.EnvVar{
						Name:  "METRICS_DOMAIN",
						Value: "tekton.dev/resolution",
					}, corev1.EnvVar{
						Name:  "ARTIFACT_HUB_API",
						Value: "https://artifacthub.io/",
					}},
					Image: "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/resolvers:v0.45.0@sha256:5bd5240ccd89e0b81796aa8b8bbb4feb2162e63dda1cb0a95e315c9fadeb7ec8",
					Name:  "controller",
					Ports: []corev1.ContainerPort{corev1.ContainerPort{
						ContainerPort: int32(9090),
						Name:          "metrics",
					}},
					Resources: corev1.ResourceRequirements{
						Limits: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("1"),
							corev1.ResourceName("memory"): resource.MustParse("4Gi"),
						},
						Requests: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("100m"),
							corev1.ResourceName("memory"): resource.MustParse("100Mi"),
						},
					},
					SecurityContext: &corev1.SecurityContext{
						Capabilities:           &corev1.Capabilities{Drop: []corev1.Capability{corev1.Capability("ALL")}},
						ReadOnlyRootFilesystem: P(true),
						RunAsNonRoot:           P(true),
						SeccompProfile:         &corev1.SeccompProfile{Type: corev1.SeccompProfileType("RuntimeDefault")},
					},
				}},
				ServiceAccountName: "tekton-pipelines-resolvers",
			},
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apps/v1",
		Kind:       "Deployment",
	},
}

var PipelinesWebhookDeploy = &appsv1.Deployment{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "webhook",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"app.kubernetes.io/version":   "v0.45.0",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	},
	Spec: appsv1.DeploymentSpec{
		Selector: &metav1.LabelSelector{MatchLabels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "webhook",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		}},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{Labels: map[string]string{
				"app":                         "tekton-pipelines-webhook",
				"app.kubernetes.io/component": "webhook",
				"app.kubernetes.io/instance":  "default",
				"app.kubernetes.io/name":      "webhook",
				"app.kubernetes.io/part-of":   "tekton-pipelines",
				"app.kubernetes.io/version":   "v0.45.0",
				"pipeline.tekton.dev/release": "v0.45.0",
				"version":                     "v0.45.0",
			}},
			Spec: corev1.PodSpec{
				Affinity: &corev1.Affinity{
					NodeAffinity: &corev1.NodeAffinity{RequiredDuringSchedulingIgnoredDuringExecution: &corev1.NodeSelector{NodeSelectorTerms: []corev1.NodeSelectorTerm{corev1.NodeSelectorTerm{MatchExpressions: []corev1.NodeSelectorRequirement{corev1.NodeSelectorRequirement{
						Key:      "kubernetes.io/os",
						Operator: corev1.NodeSelectorOperator("NotIn"),
						Values:   []string{"windows"},
					}}}}}},
					PodAntiAffinity: &corev1.PodAntiAffinity{PreferredDuringSchedulingIgnoredDuringExecution: []corev1.WeightedPodAffinityTerm{corev1.WeightedPodAffinityTerm{
						PodAffinityTerm: corev1.PodAffinityTerm{
							LabelSelector: &metav1.LabelSelector{MatchLabels: map[string]string{
								"app.kubernetes.io/component": "webhook",
								"app.kubernetes.io/instance":  "default",
								"app.kubernetes.io/name":      "webhook",
								"app.kubernetes.io/part-of":   "tekton-pipelines",
							}},
							TopologyKey: "kubernetes.io/hostname",
						},
						Weight: int32(100),
					}}},
				},
				Containers: []corev1.Container{corev1.Container{
					Env: []corev1.EnvVar{corev1.EnvVar{
						Name:      "SYSTEM_NAMESPACE",
						ValueFrom: &corev1.EnvVarSource{FieldRef: &corev1.ObjectFieldSelector{FieldPath: "metadata.namespace"}},
					}, corev1.EnvVar{
						Name:  "CONFIG_LOGGING_NAME",
						Value: "config-logging",
					}, corev1.EnvVar{
						Name:  "CONFIG_OBSERVABILITY_NAME",
						Value: "config-observability",
					}, corev1.EnvVar{
						Name:  "CONFIG_LEADERELECTION_NAME",
						Value: "config-leader-election",
					}, corev1.EnvVar{
						Name:  "CONFIG_FEATURE_FLAGS_NAME",
						Value: "feature-flags",
					}, corev1.EnvVar{
						Name:  "WEBHOOK_PORT",
						Value: "8443",
					}, corev1.EnvVar{
						Name:  "WEBHOOK_ADMISSION_CONTROLLER_NAME",
						Value: "webhook.pipeline.tekton.dev",
					}, corev1.EnvVar{
						Name:  "WEBHOOK_SERVICE_NAME",
						Value: "tekton-pipelines-webhook",
					}, corev1.EnvVar{
						Name:  "WEBHOOK_SECRET_NAME",
						Value: "webhook-certs",
					}, corev1.EnvVar{
						Name:  "METRICS_DOMAIN",
						Value: "tekton.dev/pipeline",
					}},
					Image: "gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/webhook:v0.45.0@sha256:07390c988b1c651c4810e9f7b15a88dfce8030845a429cf19b762a0d50e18ca7",
					LivenessProbe: &corev1.Probe{
						InitialDelaySeconds: int32(5),
						PeriodSeconds:       int32(10),
						ProbeHandler: corev1.ProbeHandler{HTTPGet: &corev1.HTTPGetAction{
							Path: "/health",
							Port: intstr.IntOrString{
								StrVal: "probes",
								Type:   intstr.Type(int64(1)),
							},
							Scheme: corev1.URIScheme("HTTP"),
						}},
						TimeoutSeconds: int32(5),
					},
					Name: "webhook",
					Ports: []corev1.ContainerPort{corev1.ContainerPort{
						ContainerPort: int32(9090),
						Name:          "metrics",
					}, corev1.ContainerPort{
						ContainerPort: int32(8008),
						Name:          "profiling",
					}, corev1.ContainerPort{
						ContainerPort: int32(8443),
						Name:          "https-webhook",
					}, corev1.ContainerPort{
						ContainerPort: int32(8080),
						Name:          "probes",
					}},
					ReadinessProbe: &corev1.Probe{
						InitialDelaySeconds: int32(5),
						PeriodSeconds:       int32(10),
						ProbeHandler: corev1.ProbeHandler{HTTPGet: &corev1.HTTPGetAction{
							Path: "/readiness",
							Port: intstr.IntOrString{
								StrVal: "probes",
								Type:   intstr.Type(int64(1)),
							},
							Scheme: corev1.URIScheme("HTTP"),
						}},
						TimeoutSeconds: int32(5),
					},
					Resources: corev1.ResourceRequirements{
						Limits: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("500m"),
							corev1.ResourceName("memory"): resource.MustParse("500Mi"),
						},
						Requests: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("100m"),
							corev1.ResourceName("memory"): resource.MustParse("100Mi"),
						},
					},
					SecurityContext: &corev1.SecurityContext{
						Capabilities:   &corev1.Capabilities{Drop: []corev1.Capability{corev1.Capability("ALL")}},
						RunAsGroup:     P(int64(65532)),
						RunAsNonRoot:   P(true),
						RunAsUser:      P(int64(65532)),
						SeccompProfile: &corev1.SeccompProfile{Type: corev1.SeccompProfileType("RuntimeDefault")},
					},
				}},
				ServiceAccountName: "tekton-pipelines-webhook",
			},
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apps/v1",
		Kind:       "Deployment",
	},
}
-- out/import/tekton/horizontal-pod-autoscaler.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	autoscalingv2 "k8s.io/api/autoscaling/v2"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var PipelinesWebhookHPA = &autoscalingv2.HorizontalPodAutoscaler{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "webhook",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"app.kubernetes.io/version":   "v0.45.0",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	},
	Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
		MaxReplicas: int32(5),
		Metrics: []autoscalingv2.MetricSpec{autoscalingv2.MetricSpec{
			Resource: &autoscalingv2.ResourceMetricSource{
				Name: corev1.ResourceName("cpu"),
				Target: autoscalingv2.MetricTarget{
					AverageUtilization: P(int32(100)),
					Type:               autoscalingv2.MetricTargetType("Utilization"),
				},
			},
			Type: autoscalingv2.MetricSourceType("Resource"),
		}},
		MinReplicas: P(int32(1)),
		ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
			APIVersion: "apps/v1",
			Kind:       "Deployment",
			Name:       "tekton-pipelines-webhook",
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "autoscaling/v2",
		Kind:       "HorizontalPodAutoscaler",
	},
}
-- out/import/tekton/mutating-webhook-configuration.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var WebhookPipelineDevMutatingwebhookconfigurations = &admissionregistrationv1.MutatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
		},
		Name: "webhook.pipeline.tekton.dev",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "MutatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.MutatingWebhook{admissionregistrationv1.MutatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "tekton-pipelines-webhook",
			Namespace: "tekton-pipelines",
		}},
		FailurePolicy: P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:          "webhook.pipeline.tekton.dev",
		SideEffects:   P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/tekton/namespace.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var PipelinesNS = &corev1.Namespace{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":         "default",
			"app.kubernetes.io/part-of":          "tekton-pipelines",
			"pod-security.kubernetes.io/enforce": "restricted",
		},
		Name: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Namespace",
	},
}

var PipelinesResolversNS = &corev1.Namespace{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component":        "resolvers",
			"app.kubernetes.io/instance":         "default",
			"app.kubernetes.io/part-of":          "tekton-pipelines",
			"pod-security.kubernetes.io/enforce": "restricted",
		},
		Name: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Namespace",
	},
}
-- out/import/tekton/role.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var PipelinesControllerRole = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"configmaps"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"config-logging", "config-observability", "config-artifact-bucket", "config-artifact-pvc", "feature-flags", "config-leader-election", "config-registry-cert"},
		Resources:     []string{"configmaps"},
		Verbs:         []string{"get"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}

var PipelinesInfoRole = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "tekton-pipelines-info",
		Namespace: "tekton-pipelines",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"pipelines-info"},
		Resources:     []string{"configmaps"},
		Verbs:         []string{"get"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}

var PipelinesLeaderElectionRole = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "tekton-pipelines-leader-election",
		Namespace: "tekton-pipelines",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"coordination.k8s.io"},
		Resources: []string{"leases"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}

var PipelinesResolversNamespaceRbacRole = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-resolvers-namespace-rbac",
		Namespace: "tekton-pipelines-resolvers",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"configmaps", "secrets"},
		Verbs:     []string{"get", "list", "update", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"coordination.k8s.io"},
		Resources: []string{"leases"},
		Verbs:     []string{"get", "list", "create", "update", "delete", "patch", "watch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}

var PipelinesWebhookRole = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"configmaps"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"config-logging", "config-observability", "config-leader-election", "feature-flags"},
		Resources:     []string{"configmaps"},
		Verbs:         []string{"get"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"secrets"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"webhook-certs"},
		Resources:     []string{"secrets"},
		Verbs:         []string{"get", "update"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}
-- out/import/tekton/role-binding.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var PipelinesControllerLeaderelectionRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-controller-leaderelection",
		Namespace: "tekton-pipelines",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "tekton-pipelines-leader-election",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}

var PipelinesControllerRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "tekton-pipelines-controller",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}

var PipelinesInfoRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance": "default",
			"app.kubernetes.io/part-of":  "tekton-pipelines",
		},
		Name:      "tekton-pipelines-info",
		Namespace: "tekton-pipelines",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "tekton-pipelines-info",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Group",
		Name:     "system:authenticated",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}

var PipelinesResolversNamespaceRbacRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-resolvers-namespace-rbac",
		Namespace: "tekton-pipelines-resolvers",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "tekton-pipelines-resolvers-namespace-rbac",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-resolvers",
		Namespace: "tekton-pipelines-resolvers",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}

var PipelinesWebhookLeaderelectionRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-webhook-leaderelection",
		Namespace: "tekton-pipelines",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "tekton-pipelines-leader-election",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}

var PipelinesWebhookRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "tekton-pipelines-webhook",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}
-- out/import/tekton/secret.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var WebhookCertsSecrets = &corev1.Secret{
	Data: nil,
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
		},
		Name:      "webhook-certs",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Secret",
	},
} // TODO: SECRETS SHOULD BE STORED ELSEWHERE THAN IN THE CODE!!!!
-- out/import/tekton/service.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var PipelinesControllerSVC = &corev1.Service{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app":                         "tekton-pipelines-controller",
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "controller",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"app.kubernetes.io/version":   "v0.45.0",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	},
	Spec: corev1.ServiceSpec{
		Ports: []corev1.ServicePort{corev1.ServicePort{
			Name:       "http-metrics",
			Port:       int32(9090),
			Protocol:   corev1.Protocol("TCP"),
			TargetPort: intstr.IntOrString{IntVal: int32(9090)},
		}, corev1.ServicePort{
			Name:       "http-profiling",
			Port:       int32(8008),
			TargetPort: intstr.IntOrString{IntVal: int32(8008)},
		}, corev1.ServicePort{
			Name: "probes",
			Port: int32(8080),
		}},
		Selector: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "controller",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Service",
	},
}

var PipelinesWebhookSVC = &corev1.Service{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app":                         "tekton-pipelines-webhook",
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "webhook",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"app.kubernetes.io/version":   "v0.45.0",
			"pipeline.tekton.dev/release": "v0.45.0",
			"version":                     "v0.45.0",
		},
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	},
	Spec: corev1.ServiceSpec{
		Ports: []corev1.ServicePort{corev1.ServicePort{
			Name:       "http-metrics",
			Port:       int32(9090),
			TargetPort: intstr.IntOrString{IntVal: int32(9090)},
		}, corev1.ServicePort{
			Name:       "http-profiling",
			Port:       int32(8008),
			TargetPort: intstr.IntOrString{IntVal: int32(8008)},
		}, corev1.ServicePort{
			Name: "https-webhook",
			Port: int32(443),
			TargetPort: intstr.IntOrString{
				StrVal: "https-webhook",
				Type:   intstr.Type(int64(1)),
			},
		}, corev1.ServicePort{
			Name: "probes",
			Port: int32(8080),
		}},
		Selector: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/name":      "webhook",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Service",
	},
}
-- out/import/tekton/service-account.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var PipelinesControllerSA = &corev1.ServiceAccount{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "controller",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-controller",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ServiceAccount",
	},
}

var PipelinesResolversSA = &corev1.ServiceAccount{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "resolvers",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-resolvers",
		Namespace: "tekton-pipelines-resolvers",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ServiceAccount",
	},
}

var PipelinesWebhookSA = &corev1.ServiceAccount{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
		},
		Name:      "tekton-pipelines-webhook",
		Namespace: "tekton-pipelines",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ServiceAccount",
	},
}
-- out/import/tekton/validating-webhook-configuration.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var ConfigWebhookPipelineDevValidatingwebhookconfigurations = &admissionregistrationv1.ValidatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
		},
		Name: "config.webhook.pipeline.tekton.dev",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "ValidatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.ValidatingWebhook{admissionregistrationv1.ValidatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "tekton-pipelines-webhook",
			Namespace: "tekton-pipelines",
		}},
		FailurePolicy:  P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:           "config.webhook.pipeline.tekton.dev",
		ObjectSelector: &metav1.LabelSelector{MatchLabels: map[string]string{"app.kubernetes.io/part-of": "tekton-pipelines"}},
		SideEffects:    P(admissionregistrationv1.SideEffectClass("None")),
	}},
}

var ValidationWebhookPipelineDevValidatingwebhookconfigurations = &admissionregistrationv1.ValidatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/component": "webhook",
			"app.kubernetes.io/instance":  "default",
			"app.kubernetes.io/part-of":   "tekton-pipelines",
			"pipeline.tekton.dev/release": "v0.45.0",
		},
		Name: "validation.webhook.pipeline.tekton.dev",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "ValidatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.ValidatingWebhook{admissionregistrationv1.ValidatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "tekton-pipelines-webhook",
			Namespace: "tekton-pipelines",
		}},
		FailurePolicy: P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:          "validation.webhook.pipeline.tekton.dev",
		SideEffects:   P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/tekton/app.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package tekton

import (
	"context"
	"errors"
	kube "github.com/volvo-cars/lingon/pkg/kube"
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	appsv1 "k8s.io/api/apps/v1"
	autoscalingv2 "k8s.io/api/autoscaling/v2"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"os"
	"os/exec"
)

// validate the struct implements the interface
var _ kube.Exporter = (*Tekton)(nil)

// Tekton contains kubernetes manifests
type Tekton struct {
	kube.App

	AggregateEditCR                                             *rbacv1.ClusterRole
	AggregateViewCR                                             *rbacv1.ClusterRole
	BundleresolverConfigCM                                      *corev1.ConfigMap
	ClusterResolverConfigCM                                     *corev1.ConfigMap
	ClustertasksDevCRD                                          *apiextensionsv1.CustomResourceDefinition
	ConfigArtifactBucketCM                                      *corev1.ConfigMap
	ConfigArtifactPvcCM                                         *corev1.ConfigMap
	ConfigDefaultsCM                                            *corev1.ConfigMap
	ConfigLeaderElectionCM                                      *corev1.ConfigMap
	ConfigLeaderElectionCM1                                     *corev1.ConfigMap
	ConfigLoggingCM                                             *corev1.ConfigMap
	ConfigLoggingCM2                                            *corev1.ConfigMap
	ConfigObservabilityCM                                       *corev1.ConfigMap
	ConfigObservabilityCM3                                      *corev1.ConfigMap
	ConfigRegistryCertCM                                        *corev1.ConfigMap
	ConfigSpireCM                                               *corev1.ConfigMap
	ConfigTrustedResourcesCM                                    *corev1.ConfigMap
	ConfigWebhookPipelineDevValidatingwebhookconfigurations     *admissionregistrationv1.ValidatingWebhookConfiguration
	CustomrunsDevCRD                                            *apiextensionsv1.CustomResourceDefinition
	FeatureFlagsCM                                              *corev1.ConfigMap
	GitResolverConfigCM                                         *corev1.ConfigMap
	HubresolverConfigCM                                         *corev1.ConfigMap
	PipelineresourcesDevCRD                                     *apiextensionsv1.CustomResourceDefinition
	PipelinerunsDevCRD                                          *apiextensionsv1.CustomResourceDefinition
	PipelinesControllerClusterAccessCR                          *rbacv1.ClusterRole
	PipelinesControllerClusterAccessCRB                         *rbacv1.ClusterRoleBinding
	PipelinesControllerDeploy                                   *appsv1.Deployment
	PipelinesControllerLeaderelectionRB                         *rbacv1.RoleBinding
	PipelinesControllerRB                                       *rbacv1.RoleBinding
	PipelinesControllerRole                                     *rbacv1.Role
	PipelinesControllerSA                                       *corev1.ServiceAccount
	PipelinesControllerSVC                                      *corev1.Service
	PipelinesControllerTenantAccessCR                           *rbacv1.ClusterRole
	PipelinesControllerTenantAccessCRB                          *rbacv1.ClusterRoleBinding
	PipelinesDevCRD                                             *apiextensionsv1.CustomResourceDefinition
	PipelinesInfoCM                                             *corev1.ConfigMap
	PipelinesInfoRB                                             *rbacv1.RoleBinding
	PipelinesInfoRole                                           *rbacv1.Role
	PipelinesLeaderElectionRole                                 *rbacv1.Role
	PipelinesNS                                                 *corev1.Namespace
	PipelinesRemoteResolversDeploy                              *appsv1.Deployment
	PipelinesResolversCRB                                       *rbacv1.ClusterRoleBinding
	PipelinesResolversNS                                        *corev1.Namespace
	PipelinesResolversNamespaceRbacRB                           *rbacv1.RoleBinding
	PipelinesResolversNamespaceRbacRole                         *rbacv1.Role
	PipelinesResolversResolutionRequestUpdatesCR                *rbacv1.ClusterRole
	PipelinesResolversSA                                        *corev1.ServiceAccount
	PipelinesWebhookClusterAccessCR                             *rbacv1.ClusterRole
	PipelinesWebhookClusterAccessCRB                            *rbacv1.ClusterRoleBinding
	PipelinesWebhookDeploy                                      *appsv1.Deployment
	PipelinesWebhookHPA                                         *autoscalingv2.HorizontalPodAutoscaler
	PipelinesWebhookLeaderelectionRB                            *rbacv1.RoleBinding
	PipelinesWebhookRB                                          *rbacv1.RoleBinding
	PipelinesWebhookRole                                        *rbacv1.Role
	PipelinesWebhookSA                                          *corev1.ServiceAccount
	PipelinesWebhookSVC                                         *corev1.Service
	ResolutionrequestsResolutionDevCRD                          *apiextensionsv1.CustomResourceDefinition
	ResolversFeatureFlagsCM                                     *corev1.ConfigMap
	RunsDevCRD                                                  *apiextensionsv1.CustomResourceDefinition
	TaskrunsDevCRD                                              *apiextensionsv1.CustomResourceDefinition
	TasksDevCRD                                                 *apiextensionsv1.CustomResourceDefinition
	ValidationWebhookPipelineDevValidatingwebhookconfigurations *admissionregistrationv1.ValidatingWebhookConfiguration
	VerificationpoliciesDevCRD                                  *apiextensionsv1.CustomResourceDefinition
	WebhookCertsSecrets                                         *corev1.Secret
	WebhookPipelineDevMutatingwebhookconfigurations             *admissionregistrationv1.MutatingWebhookConfiguration
}

// New creates a new Tekton
func New() *Tekton {
	return &Tekton{
		AggregateEditCR:          AggregateEditCR,
		AggregateViewCR:          AggregateViewCR,
		BundleresolverConfigCM:   BundleresolverConfigCM,
		ClusterResolverConfigCM:  ClusterResolverConfigCM,
		ClustertasksDevCRD:       ClustertasksDevCRD,
		ConfigArtifactBucketCM:   ConfigArtifactBucketCM,
		ConfigArtifactPvcCM:      ConfigArtifactPvcCM,
		ConfigDefaultsCM:         ConfigDefaultsCM,
		ConfigLeaderElectionCM:   ConfigLeaderElectionCM,
		ConfigLeaderElectionCM1:  ConfigLeaderElectionCM1,
		ConfigLoggingCM:          ConfigLoggingCM,
		ConfigLoggingCM2:         ConfigLoggingCM2,
		ConfigObservabilityCM:    ConfigObservabilityCM,
		ConfigObservabilityCM3:   ConfigObservabilityCM3,
		ConfigRegistryCertCM:     ConfigRegistryCertCM,
		ConfigSpireCM:            ConfigSpireCM,
		ConfigTrustedResourcesCM: ConfigTrustedResourcesCM,
		ConfigWebhookPipelineDevValidatingwebhookconfigurations: ConfigWebhookPipelineDevValidatingwebhookconfigurations,
		CustomrunsDevCRD:                             CustomrunsDevCRD,
		FeatureFlagsCM:                               FeatureFlagsCM,
		GitResolverConfigCM:                          GitResolverConfigCM,
		HubresolverConfigCM:                          HubresolverConfigCM,
		PipelineresourcesDevCRD:                      PipelineresourcesDevCRD,
		PipelinerunsDevCRD:                           PipelinerunsDevCRD,
		PipelinesControllerClusterAccessCR:           PipelinesControllerClusterAccessCR,
		PipelinesControllerClusterAccessCRB:          PipelinesControllerClusterAccessCRB,
		PipelinesControllerDeploy:                    PipelinesControllerDeploy,
		PipelinesControllerLeaderelectionRB:          PipelinesControllerLeaderelectionRB,
		PipelinesControllerRB:                        PipelinesControllerRB,
		PipelinesControllerRole:                      PipelinesControllerRole,
		PipelinesControllerSA:                        PipelinesControllerSA,
		PipelinesControllerSVC:                       PipelinesControllerSVC,
		PipelinesControllerTenantAccessCR:            PipelinesControllerTenantAccessCR,
		PipelinesControllerTenantAccessCRB:           PipelinesControllerTenantAccessCRB,
		PipelinesDevCRD:                              PipelinesDevCRD,
		PipelinesInfoCM:                              PipelinesInfoCM,
		PipelinesInfoRB:                              PipelinesInfoRB,
		PipelinesInfoRole:                            PipelinesInfoRole,
		PipelinesLeaderElectionRole:                  PipelinesLeaderElectionRole,
		PipelinesNS:                                  PipelinesNS,
		PipelinesRemoteResolversDeploy:               PipelinesRemoteResolversDeploy,
		PipelinesResolversCRB:                        PipelinesResolversCRB,
		PipelinesResolversNS:                         PipelinesResolversNS,
		PipelinesResolversNamespaceRbacRB:            PipelinesResolversNamespaceRbacRB,
		PipelinesResolversNamespaceRbacRole:          PipelinesResolversNamespaceRbacRole,
		PipelinesResolversResolutionRequestUpdatesCR: PipelinesResolversResolutionRequestUpdatesCR,
		PipelinesResolversSA:                         PipelinesResolversSA,
		PipelinesWebhookClusterAccessCR:              PipelinesWebhookClusterAccessCR,
		PipelinesWebhookClusterAccessCRB:             PipelinesWebhookClusterAccessCRB,
		PipelinesWebhookDeploy:                       PipelinesWebhookDeploy,
		PipelinesWebhookHPA:                          PipelinesWebhookHPA,
		PipelinesWebhookLeaderelectionRB:             PipelinesWebhookLeaderelectionRB,
		PipelinesWebhookRB:                           PipelinesWebhookRB,
		PipelinesWebhookRole:                         PipelinesWebhookRole,
		PipelinesWebhookSA:                           PipelinesWebhookSA,
		PipelinesWebhookSVC:                          PipelinesWebhookSVC,
		ResolutionrequestsResolutionDevCRD:           ResolutionrequestsResolutionDevCRD,
		ResolversFeatureFlagsCM:                      ResolversFeatureFlagsCM,
		RunsDevCRD:                                   RunsDevCRD,
		TaskrunsDevCRD:                               TaskrunsDevCRD,
		TasksDevCRD:                                  TasksDevCRD,
		ValidationWebhookPipelineDevValidatingwebhookconfigurations: ValidationWebhookPipelineDevValidatingwebhookconfigurations,
		VerificationpoliciesDevCRD:                                  VerificationpoliciesDevCRD,
		WebhookCertsSecrets:                                         WebhookCertsSecrets,
		WebhookPipelineDevMutatingwebhookconfigurations:             WebhookPipelineDevMutatingwebhookconfigurations}
}

// Apply applies the kubernetes objects to the cluster
func (a *Tekton) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *Tekton) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(km, kube.WithExportWriter(stdin), kube.WithExportAsSingleFile("stdin")); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}
