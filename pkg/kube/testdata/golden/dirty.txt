-- out/metadata-grpc_deploy.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package lingon

import (
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var MetadataGrpcDeploy = &appsv1.Deployment{
	ObjectMeta: metav1.ObjectMeta{
		Annotations: map[string]string{"deployment.kubernetes.io/revision": "8"},
		Labels: map[string]string{
			"application-crd-id":          "kubeflow-pipelines",
			"argocd.argoproj.io/instance": "pipelines-kubeflow",
			"component":                   "metadata-grpc-server",
		},
		Name:      "metadata-grpc-deployment",
		Namespace: "kubeflow",
	},
	Spec: appsv1.DeploymentSpec{
		ProgressDeadlineSeconds: P(int32(600)),
		Replicas:                P(int32(1)),
		RevisionHistoryLimit:    P(int32(10)),
		Selector: &metav1.LabelSelector{MatchLabels: map[string]string{
			"application-crd-id": "kubeflow-pipelines",
			"component":          "metadata-grpc-server",
		}},
		Strategy: appsv1.DeploymentStrategy{
			RollingUpdate: &appsv1.RollingUpdateDeployment{
				MaxSurge: &intstr.IntOrString{
					StrVal: "25%",
					Type:   intstr.Type(int64(1)),
				},
				MaxUnavailable: &intstr.IntOrString{
					StrVal: "25%",
					Type:   intstr.Type(int64(1)),
				},
			},
			Type: appsv1.DeploymentStrategyType("RollingUpdate"),
		},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Annotations: map[string]string{"kubectl.kubernetes.io/restartedAt": "2023-02-22T11:20:01+01:00"},
				Labels: map[string]string{
					"application-crd-id": "kubeflow-pipelines",
					"component":          "metadata-grpc-server",
				},
			},
			Spec: corev1.PodSpec{
				Containers: []corev1.Container{corev1.Container{
					Args:    []string{"--grpc_port=8080", "--mysql_config_database=$(MYSQL_DATABASE)", "--mysql_config_host=$(MYSQL_HOST)", "--mysql_config_port=$(MYSQL_PORT)", "--mysql_config_user=$(DBCONFIG_USER)", "--mysql_config_password=$(DBCONFIG_PASSWORD)", "--enable_database_upgrade=true"},
					Command: []string{"/bin/metadata_store_server"},
					Env: []corev1.EnvVar{corev1.EnvVar{
						Name: "DBCONFIG_USER",
						ValueFrom: &corev1.EnvVarSource{SecretKeyRef: &corev1.SecretKeySelector{
							Key:                  "username",
							LocalObjectReference: corev1.LocalObjectReference{Name: "kubeflow-pipelines-db-credentials"},
						}},
					}, corev1.EnvVar{
						Name: "DBCONFIG_PASSWORD",
						ValueFrom: &corev1.EnvVarSource{SecretKeyRef: &corev1.SecretKeySelector{
							Key:                  "password",
							LocalObjectReference: corev1.LocalObjectReference{Name: "kubeflow-pipelines-db-credentials"},
						}},
					}, corev1.EnvVar{
						Name: "MYSQL_DATABASE",
						ValueFrom: &corev1.EnvVarSource{ConfigMapKeyRef: &corev1.ConfigMapKeySelector{
							Key:                  "mlmdDb",
							LocalObjectReference: corev1.LocalObjectReference{Name: "pipeline-install-config"},
						}},
					}, corev1.EnvVar{
						Name: "MYSQL_HOST",
						ValueFrom: &corev1.EnvVarSource{SecretKeyRef: &corev1.SecretKeySelector{
							Key:                  "hostname",
							LocalObjectReference: corev1.LocalObjectReference{Name: "kubeflow-pipelines-db-credentials"},
						}},
					}, corev1.EnvVar{
						Name: "MYSQL_PORT",
						ValueFrom: &corev1.EnvVarSource{ConfigMapKeyRef: &corev1.ConfigMapKeySelector{
							Key:                  "dbPort",
							LocalObjectReference: corev1.LocalObjectReference{Name: "pipeline-install-config"},
						}},
					}},
					Image:           "gcr.io/tfx-oss-public/ml_metadata_store_server:1.5.0",
					ImagePullPolicy: corev1.PullPolicy("IfNotPresent"),
					LivenessProbe: &corev1.Probe{
						FailureThreshold:    int32(3),
						InitialDelaySeconds: int32(3),
						PeriodSeconds:       int32(5),
						ProbeHandler: corev1.ProbeHandler{TCPSocket: &corev1.TCPSocketAction{Port: intstr.IntOrString{
							StrVal: "grpc-api",
							Type:   intstr.Type(int64(1)),
						}}},
						SuccessThreshold: int32(1),
						TimeoutSeconds:   int32(2),
					},
					Name: "container",
					Ports: []corev1.ContainerPort{corev1.ContainerPort{
						ContainerPort: int32(8080),
						Name:          "grpc-api",
						Protocol:      corev1.Protocol("TCP"),
					}},
					ReadinessProbe: &corev1.Probe{
						FailureThreshold:    int32(3),
						InitialDelaySeconds: int32(3),
						PeriodSeconds:       int32(5),
						ProbeHandler: corev1.ProbeHandler{TCPSocket: &corev1.TCPSocketAction{Port: intstr.IntOrString{
							StrVal: "grpc-api",
							Type:   intstr.Type(int64(1)),
						}}},
						SuccessThreshold: int32(1),
						TimeoutSeconds:   int32(2),
					},
					Resources: corev1.ResourceRequirements{
						Limits: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("250m"),
							corev1.ResourceName("memory"): resource.MustParse("512Mi"),
						},
						Requests: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("50m"),
							corev1.ResourceName("memory"): resource.MustParse("128Mi"),
						},
					},
					TerminationMessagePath:   "/dev/termination-log",
					TerminationMessagePolicy: corev1.TerminationMessagePolicy("File"),
				}},
				DNSPolicy:                     corev1.DNSPolicy("ClusterFirst"),
				DeprecatedServiceAccount:      "metadata-grpc-server",
				RestartPolicy:                 corev1.RestartPolicy("Always"),
				SchedulerName:                 "default-scheduler",
				ServiceAccountName:            "metadata-grpc-server",
				TerminationGracePeriodSeconds: P(int64(30)),
			},
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apps/v1",
		Kind:       "Deployment",
	},
}
-- out/app.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package lingon

import (
	"context"
	"errors"
	kube "github.com/volvo-cars/lingon/pkg/kube"
	appsv1 "k8s.io/api/apps/v1"
	"os"
	"os/exec"
)

// validate the struct implements the interface
var _ kube.Exporter = (*Lingon)(nil)

// Lingon contains kubernetes manifests
type Lingon struct {
	kube.App

	MetadataGrpcDeploy *appsv1.Deployment
}

// New creates a new Lingon
func New() *Lingon {
	return &Lingon{
		MetadataGrpcDeploy: MetadataGrpcDeploy}
}

// Apply applies the kubernetes objects to the cluster
func (a *Lingon) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *Lingon) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(km, kube.WithExportWriter(stdin), kube.WithExportAsSingleFile("stdin")); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}
