-- out/import/karpenter/admin_cr.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var AdminCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":                   "karpenter",
			"app.kubernetes.io/managed-by":                 "Helm",
			"app.kubernetes.io/name":                       "karpenter",
			"app.kubernetes.io/version":                    "0.24.0",
			"helm.sh/chart":                                "karpenter-v0.24.0",
			"rbac.authorization.k8s.io/aggregate-to-admin": "true",
		},
		Name: "karpenter-admin",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"karpenter.sh"},
		Resources: []string{"provisioners", "provisioners/status"},
		Verbs:     []string{"get", "list", "watch", "create", "delete", "patch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"karpenter.k8s.aws"},
		Resources: []string{"awsnodetemplates"},
		Verbs:     []string{"get", "list", "watch", "create", "delete", "patch"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}
-- out/import/karpenter/cr.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var CR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "karpenter",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"karpenter.k8s.aws"},
		Resources: []string{"awsnodetemplates"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"admissionregistration.k8s.io"},
		ResourceNames: []string{"validation.webhook.karpenter.k8s.aws"},
		Resources:     []string{"validatingwebhookconfigurations"},
		Verbs:         []string{"update"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"admissionregistration.k8s.io"},
		ResourceNames: []string{"defaulting.webhook.karpenter.k8s.aws"},
		Resources:     []string{"mutatingwebhookconfigurations"},
		Verbs:         []string{"update"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"karpenter.k8s.aws"},
		Resources: []string{"awsnodetemplates/status"},
		Verbs:     []string{"patch", "update"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}
-- out/import/karpenter/crb.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var CRB = &rbacv1.ClusterRoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "karpenter",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "karpenter",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "karpenter",
		Namespace: "karpenter",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRoleBinding",
	},
}
-- out/import/karpenter/cert_secrets.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var CertSecrets = &corev1.Secret{
	Data: map[string][]byte{},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter-cert",
		Namespace: "karpenter",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Secret",
	},
} // TODO: SECRETS SHOULD BE STORED ELSEWHERE THAN IN THE CODE!!!!
-- out/import/karpenter/config-logging_cm.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var ConfigLoggingCM = &corev1.ConfigMap{
	Data: map[string]string{
		"loglevel.webhook": "error",
		// https://github.com/uber-go/zap/blob/aa3e73ec0896f8b066ddf668597a02f89628ee50/config.go
		"zap-logger-config": `{
  "level": "debug",
  "development": false,
  "disableStacktrace": true,
  "disableCaller": true,
  "sampling": {
    "initial": 100,
    "thereafter": 100
  },
  "outputPaths": ["stdout"],
  "errorOutputPaths": ["stderr"],
  "encoding": "console",
  "encoderConfig": {
    "timeKey": "time",
    "levelKey": "level",
    "nameKey": "logger",
    "callerKey": "caller",
    "messageKey": "message",
    "stacktraceKey": "stacktrace",
    "levelEncoder": "capital",
    "timeEncoder": "iso8601"
  }
}
`},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "config-logging",
		Namespace: "karpenter",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}
-- out/import/karpenter/core_cr.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var CoreCR = &rbacv1.ClusterRole{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "karpenter-core",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"karpenter.sh"},
		Resources: []string{"provisioners", "provisioners/status", "machines", "machines/status"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"pods", "nodes", "persistentvolumes", "persistentvolumeclaims", "replicationcontrollers", "namespaces"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"storage.k8s.io"},
		Resources: []string{"storageclasses", "csinodes"},
		Verbs:     []string{"get", "watch", "list"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"apps"},
		Resources: []string{"daemonsets", "deployments", "replicasets", "statefulsets"},
		Verbs:     []string{"list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"admissionregistration.k8s.io"},
		Resources: []string{"validatingwebhookconfigurations", "mutatingwebhookconfigurations"},
		Verbs:     []string{"get", "watch", "list"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"policy"},
		Resources: []string{"poddisruptionbudgets"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"karpenter.sh"},
		Resources: []string{"provisioners/status", "machines", "machines/status"},
		Verbs:     []string{"create", "delete", "patch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"events"},
		Verbs:     []string{"create", "patch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"nodes"},
		Verbs:     []string{"create", "patch", "delete"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"pods/eviction"},
		Verbs:     []string{"create"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"admissionregistration.k8s.io"},
		ResourceNames: []string{"validation.webhook.karpenter.sh", "validation.webhook.config.karpenter.sh"},
		Resources:     []string{"validatingwebhookconfigurations"},
		Verbs:         []string{"update"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"admissionregistration.k8s.io"},
		ResourceNames: []string{"defaulting.webhook.karpenter.sh"},
		Resources:     []string{"mutatingwebhookconfigurations"},
		Verbs:         []string{"update"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRole",
	},
}
-- out/import/karpenter/core_crb.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var CoreCRB = &rbacv1.ClusterRoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "karpenter-core",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "ClusterRole",
		Name:     "karpenter-core",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "karpenter",
		Namespace: "karpenter",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "ClusterRoleBinding",
	},
}
-- out/import/karpenter/defaulting.webhook..k8s.aws_mutatingwebhookconfigurations.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var DefaultingWebhookK8SAwsMutatingwebhookconfigurations = &admissionregistrationv1.MutatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "defaulting.webhook.karpenter.k8s.aws",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "MutatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.MutatingWebhook{admissionregistrationv1.MutatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "karpenter",
			Namespace: "karpenter",
		}},
		FailurePolicy: P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:          "defaulting.webhook.karpenter.k8s.aws",
		Rules: []admissionregistrationv1.RuleWithOperations{admissionregistrationv1.RuleWithOperations{
			Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationType("CREATE"), admissionregistrationv1.OperationType("UPDATE")},
			Rule: admissionregistrationv1.Rule{
				APIGroups:   []string{"karpenter.k8s.aws"},
				APIVersions: []string{"v1alpha1"},
				Resources:   []string{"awsnodetemplates", "awsnodetemplates/status"},
				Scope:       P(admissionregistrationv1.ScopeType("*")),
			},
		}, admissionregistrationv1.RuleWithOperations{
			Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationType("CREATE"), admissionregistrationv1.OperationType("UPDATE")},
			Rule: admissionregistrationv1.Rule{
				APIGroups:   []string{"karpenter.sh"},
				APIVersions: []string{"v1alpha5"},
				Resources:   []string{"provisioners", "provisioners/status"},
			},
		}},
		SideEffects: P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/karpenter/defaulting.webhook..sh_mutatingwebhookconfigurations.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var DefaultingWebhookShMutatingwebhookconfigurations = &admissionregistrationv1.MutatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "defaulting.webhook.karpenter.sh",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "MutatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.MutatingWebhook{admissionregistrationv1.MutatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "karpenter",
			Namespace: "karpenter",
		}},
		FailurePolicy: P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:          "defaulting.webhook.karpenter.sh",
		Rules: []admissionregistrationv1.RuleWithOperations{admissionregistrationv1.RuleWithOperations{
			Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationType("CREATE"), admissionregistrationv1.OperationType("UPDATE")},
			Rule: admissionregistrationv1.Rule{
				APIGroups:   []string{"karpenter.sh"},
				APIVersions: []string{"v1alpha5"},
				Resources:   []string{"provisioners", "provisioners/status"},
			},
		}},
		SideEffects: P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/karpenter/deploy.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var Deploy = &appsv1.Deployment{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter",
		Namespace: "karpenter",
	},
	Spec: appsv1.DeploymentSpec{
		Replicas:             P(int32(2)),
		RevisionHistoryLimit: P(int32(10)),
		Selector: &metav1.LabelSelector{MatchLabels: map[string]string{
			"app.kubernetes.io/instance": "karpenter",
			"app.kubernetes.io/name":     "karpenter",
		}},
		Strategy: appsv1.DeploymentStrategy{RollingUpdate: &appsv1.RollingUpdateDeployment{MaxUnavailable: &intstr.IntOrString{IntVal: int32(1)}}},
		Template: corev1.PodTemplateSpec{
			ObjectMeta: metav1.ObjectMeta{
				Annotations: map[string]string{"checksum/settings": "2f12e017e74649875e78e4cdc8b06340ed07891a7002b5a3486cdc02f2705eaa"},
				Labels: map[string]string{
					"app.kubernetes.io/instance": "karpenter",
					"app.kubernetes.io/name":     "karpenter",
				},
			},
			Spec: corev1.PodSpec{
				Affinity: &corev1.Affinity{NodeAffinity: &corev1.NodeAffinity{RequiredDuringSchedulingIgnoredDuringExecution: &corev1.NodeSelector{NodeSelectorTerms: []corev1.NodeSelectorTerm{corev1.NodeSelectorTerm{MatchExpressions: []corev1.NodeSelectorRequirement{corev1.NodeSelectorRequirement{
					Key:      "karpenter.sh/provisioner-name",
					Operator: corev1.NodeSelectorOperator("DoesNotExist"),
				}}}}}}},
				Containers: []corev1.Container{corev1.Container{
					Env: []corev1.EnvVar{corev1.EnvVar{
						Name:  "KUBERNETES_MIN_VERSION",
						Value: "1.19.0-0",
					}, corev1.EnvVar{
						Name:  "KARPENTER_SERVICE",
						Value: "karpenter",
					}, corev1.EnvVar{
						Name:  "WEBHOOK_PORT",
						Value: "8443",
					}, corev1.EnvVar{
						Name:  "METRICS_PORT",
						Value: "8080",
					}, corev1.EnvVar{
						Name:  "HEALTH_PROBE_PORT",
						Value: "8081",
					}, corev1.EnvVar{
						Name:      "SYSTEM_NAMESPACE",
						ValueFrom: &corev1.EnvVarSource{FieldRef: &corev1.ObjectFieldSelector{FieldPath: "metadata.namespace"}},
					}, corev1.EnvVar{
						Name: "MEMORY_LIMIT",
						ValueFrom: &corev1.EnvVarSource{ResourceFieldRef: &corev1.ResourceFieldSelector{
							ContainerName: "controller",
							Divisor:       resource.MustParse("0"),
							Resource:      "limits.memory",
						}},
					}},
					Image:           "public.ecr.aws/karpenter/controller:v0.24.0@sha256:83e7a21200efd4e17314c931aa715c9c73b27fcbf08673d263c007029ad754da",
					ImagePullPolicy: corev1.PullPolicy("IfNotPresent"),
					LivenessProbe: &corev1.Probe{
						InitialDelaySeconds: int32(30),
						ProbeHandler: corev1.ProbeHandler{HTTPGet: &corev1.HTTPGetAction{
							Path: "/healthz",
							Port: intstr.IntOrString{
								StrVal: "http",
								Type:   intstr.Type(int64(1)),
							},
						}},
						TimeoutSeconds: int32(30),
					},
					Name: "controller",
					Ports: []corev1.ContainerPort{corev1.ContainerPort{
						ContainerPort: int32(8080),
						Name:          "http-metrics",
						Protocol:      corev1.Protocol("TCP"),
					}, corev1.ContainerPort{
						ContainerPort: int32(8081),
						Name:          "http",
						Protocol:      corev1.Protocol("TCP"),
					}, corev1.ContainerPort{
						ContainerPort: int32(8443),
						Name:          "https-webhook",
						Protocol:      corev1.Protocol("TCP"),
					}},
					ReadinessProbe: &corev1.Probe{
						ProbeHandler: corev1.ProbeHandler{HTTPGet: &corev1.HTTPGetAction{
							Path: "/readyz",
							Port: intstr.IntOrString{
								StrVal: "http",
								Type:   intstr.Type(int64(1)),
							},
						}},
						TimeoutSeconds: int32(30),
					},
					Resources: corev1.ResourceRequirements{
						Limits: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("1"),
							corev1.ResourceName("memory"): resource.MustParse("1Gi"),
						},
						Requests: map[corev1.ResourceName]resource.Quantity{
							corev1.ResourceName("cpu"):    resource.MustParse("1"),
							corev1.ResourceName("memory"): resource.MustParse("1Gi"),
						},
					},
				}},
				DNSPolicy:          corev1.DNSPolicy("Default"),
				NodeSelector:       map[string]string{"kubernetes.io/os": "linux"},
				PriorityClassName:  "system-cluster-critical",
				SecurityContext:    &corev1.PodSecurityContext{FSGroup: P(int64(1000))},
				ServiceAccountName: "karpenter",
				Tolerations: []corev1.Toleration{corev1.Toleration{
					Key:      "CriticalAddonsOnly",
					Operator: corev1.TolerationOperator("Exists"),
				}},
				TopologySpreadConstraints: []corev1.TopologySpreadConstraint{corev1.TopologySpreadConstraint{
					LabelSelector: &metav1.LabelSelector{MatchLabels: map[string]string{
						"app.kubernetes.io/instance": "karpenter",
						"app.kubernetes.io/name":     "karpenter",
					}},
					MaxSkew:           int32(1),
					TopologyKey:       "topology.kubernetes.io/zone",
					WhenUnsatisfiable: corev1.UnsatisfiableConstraintAction("ScheduleAnyway"),
				}},
			},
		},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "apps/v1",
		Kind:       "Deployment",
	},
}
-- out/import/karpenter/dns_rb.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var DnsRB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter-dns",
		Namespace: "kube-system",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "karpenter-dns",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "karpenter",
		Namespace: "karpenter",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}
-- out/import/karpenter/dns_role.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var DnsRole = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter-dns",
		Namespace: "kube-system",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"kube-dns"},
		Resources:     []string{"services"},
		Verbs:         []string{"get"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}
-- out/import/karpenter/global-settings_cm.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var GlobalSettingsCM = &corev1.ConfigMap{
	Data: map[string]string{
		"aws.clusterEndpoint":            "CLUSTER_ENDPOINT",
		"aws.clusterName":                "CLUSTER_NAME",
		"aws.defaultInstanceProfile":     "KarpenterNodeInstanceProfile-CLUSTER_NAME",
		"aws.enableENILimitedPodDensity": "true",
		"aws.enablePodENI":               "false",
		"aws.interruptionQueueName":      "CLUSTER_NAME",
		"aws.isolatedVPC":                "false",
		"aws.nodeNameConvention":         "ip-name",
		"aws.vmMemoryOverheadPercent":    "0.075",
		"batchIdleDuration":              "1s",
		"batchMaxDuration":               "10s"},
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter-global-settings",
		Namespace: "karpenter",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ConfigMap",
	},
}
-- out/import/karpenter/pdb.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	policyv1 "k8s.io/api/policy/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var PDB = &policyv1.PodDisruptionBudget{
	ObjectMeta: metav1.ObjectMeta{
		Name:      "karpenter",
		Namespace: "karpenter",
	},
	Spec: policyv1.PodDisruptionBudgetSpec{
		MaxUnavailable: &intstr.IntOrString{IntVal: int32(1)},
		Selector: &metav1.LabelSelector{MatchLabels: map[string]string{
			"app.kubernetes.io/instance": "karpenter",
			"app.kubernetes.io/name":     "karpenter",
		}},
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "policy/v1",
		Kind:       "PodDisruptionBudget",
	},
}
-- out/import/karpenter/rb.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var RB = &rbacv1.RoleBinding{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter",
		Namespace: "karpenter",
	},
	RoleRef: rbacv1.RoleRef{
		APIGroup: "rbac.authorization.k8s.io",
		Kind:     "Role",
		Name:     "karpenter",
	},
	Subjects: []rbacv1.Subject{rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      "karpenter",
		Namespace: "karpenter",
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "RoleBinding",
	},
}
-- out/import/karpenter/role.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var Role = &rbacv1.Role{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter",
		Namespace: "karpenter",
	},
	Rules: []rbacv1.PolicyRule{rbacv1.PolicyRule{
		APIGroups: []string{"coordination.k8s.io"},
		Resources: []string{"leases"},
		Verbs:     []string{"get", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"configmaps", "namespaces", "secrets"},
		Verbs:     []string{"get", "list", "watch"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"karpenter-cert"},
		Resources:     []string{"secrets"},
		Verbs:         []string{"update"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{""},
		ResourceNames: []string{"karpenter-global-settings", "config-logging"},
		Resources:     []string{"configmaps"},
		Verbs:         []string{"update", "patch", "delete"},
	}, rbacv1.PolicyRule{
		APIGroups:     []string{"coordination.k8s.io"},
		ResourceNames: []string{"karpenter-leader-election", "webhook.configmapwebhook.00-of-01", "webhook.defaultingwebhook.00-of-01", "webhook.validationwebhook.00-of-01", "webhook.webhookcertificates.00-of-01"},
		Resources:     []string{"leases"},
		Verbs:         []string{"patch", "update"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{"coordination.k8s.io"},
		Resources: []string{"leases"},
		Verbs:     []string{"create"},
	}, rbacv1.PolicyRule{
		APIGroups: []string{""},
		Resources: []string{"configmaps"},
		Verbs:     []string{"create"},
	}},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "rbac.authorization.k8s.io/v1",
		Kind:       "Role",
	},
}
-- out/import/karpenter/sa.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var SA = &corev1.ServiceAccount{
	ObjectMeta: metav1.ObjectMeta{
		Annotations: map[string]string{"eks.amazonaws.com/role-arn": "KARPENTER_IAM_ROLE_ARN"},
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter",
		Namespace: "karpenter",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "ServiceAccount",
	},
}
-- out/import/karpenter/svc.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

var SVC = &corev1.Service{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name:      "karpenter",
		Namespace: "karpenter",
	},
	Spec: corev1.ServiceSpec{
		Ports: []corev1.ServicePort{corev1.ServicePort{
			Name:     "http-metrics",
			Port:     int32(8080),
			Protocol: corev1.Protocol("TCP"),
			TargetPort: intstr.IntOrString{
				StrVal: "http-metrics",
				Type:   intstr.Type(int64(1)),
			},
		}, corev1.ServicePort{
			Name:     "https-webhook",
			Port:     int32(443),
			Protocol: corev1.Protocol("TCP"),
			TargetPort: intstr.IntOrString{
				StrVal: "https-webhook",
				Type:   intstr.Type(int64(1)),
			},
		}},
		Selector: map[string]string{
			"app.kubernetes.io/instance": "karpenter",
			"app.kubernetes.io/name":     "karpenter",
		},
		Type: corev1.ServiceType("ClusterIP"),
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "v1",
		Kind:       "Service",
	},
}
-- out/import/karpenter/validation.webhook.config..sh_validatingwebhookconfigurations.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var ValidationWebhookConfigShValidatingwebhookconfigurations = &admissionregistrationv1.ValidatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "validation.webhook.config.karpenter.sh",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "ValidatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.ValidatingWebhook{admissionregistrationv1.ValidatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "karpenter",
			Namespace: "karpenter",
		}},
		FailurePolicy:  P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:           "validation.webhook.config.karpenter.sh",
		ObjectSelector: &metav1.LabelSelector{MatchLabels: map[string]string{"app.kubernetes.io/part-of": "karpenter"}},
		SideEffects:    P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/karpenter/validation.webhook..k8s.aws_validatingwebhookconfigurations.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var ValidationWebhookK8SAwsValidatingwebhookconfigurations = &admissionregistrationv1.ValidatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "validation.webhook.karpenter.k8s.aws",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "ValidatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.ValidatingWebhook{admissionregistrationv1.ValidatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "karpenter",
			Namespace: "karpenter",
		}},
		FailurePolicy: P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:          "validation.webhook.karpenter.k8s.aws",
		Rules: []admissionregistrationv1.RuleWithOperations{admissionregistrationv1.RuleWithOperations{
			Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationType("CREATE"), admissionregistrationv1.OperationType("UPDATE"), admissionregistrationv1.OperationType("DELETE")},
			Rule: admissionregistrationv1.Rule{
				APIGroups:   []string{"karpenter.k8s.aws"},
				APIVersions: []string{"v1alpha1"},
				Resources:   []string{"awsnodetemplates", "awsnodetemplates/status"},
				Scope:       P(admissionregistrationv1.ScopeType("*")),
			},
		}, admissionregistrationv1.RuleWithOperations{
			Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationType("CREATE"), admissionregistrationv1.OperationType("UPDATE"), admissionregistrationv1.OperationType("DELETE")},
			Rule: admissionregistrationv1.Rule{
				APIGroups:   []string{"karpenter.sh"},
				APIVersions: []string{"v1alpha5"},
				Resources:   []string{"provisioners", "provisioners/status"},
			},
		}},
		SideEffects: P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/karpenter/validation.webhook..sh_validatingwebhookconfigurations.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var ValidationWebhookShValidatingwebhookconfigurations = &admissionregistrationv1.ValidatingWebhookConfiguration{
	ObjectMeta: metav1.ObjectMeta{
		Labels: map[string]string{
			"app.kubernetes.io/instance":   "karpenter",
			"app.kubernetes.io/managed-by": "Helm",
			"app.kubernetes.io/name":       "karpenter",
			"app.kubernetes.io/version":    "0.24.0",
			"helm.sh/chart":                "karpenter-v0.24.0",
		},
		Name: "validation.webhook.karpenter.sh",
	},
	TypeMeta: metav1.TypeMeta{
		APIVersion: "admissionregistration.k8s.io/v1",
		Kind:       "ValidatingWebhookConfiguration",
	},
	Webhooks: []admissionregistrationv1.ValidatingWebhook{admissionregistrationv1.ValidatingWebhook{
		AdmissionReviewVersions: []string{"v1"},
		ClientConfig: admissionregistrationv1.WebhookClientConfig{Service: &admissionregistrationv1.ServiceReference{
			Name:      "karpenter",
			Namespace: "karpenter",
		}},
		FailurePolicy: P(admissionregistrationv1.FailurePolicyType("Fail")),
		Name:          "validation.webhook.karpenter.sh",
		Rules: []admissionregistrationv1.RuleWithOperations{admissionregistrationv1.RuleWithOperations{
			Operations: []admissionregistrationv1.OperationType{admissionregistrationv1.OperationType("CREATE"), admissionregistrationv1.OperationType("UPDATE"), admissionregistrationv1.OperationType("DELETE")},
			Rule: admissionregistrationv1.Rule{
				APIGroups:   []string{"karpenter.sh"},
				APIVersions: []string{"v1alpha5"},
				Resources:   []string{"provisioners", "provisioners/status"},
			},
		}},
		SideEffects: P(admissionregistrationv1.SideEffectClass("None")),
	}},
}
-- out/import/karpenter/app.go --
// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package karpenter

import (
	"context"
	"errors"
	kube "github.com/golingon/lingon/pkg/kube"
	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	policyv1 "k8s.io/api/policy/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"os"
	"os/exec"
)

// validate the struct implements the interface
var _ kube.Exporter = (*Karpenter)(nil)

// Karpenter contains kubernetes manifests
type Karpenter struct {
	kube.App

	AdminCR                                                  *rbacv1.ClusterRole
	CR                                                       *rbacv1.ClusterRole
	CRB                                                      *rbacv1.ClusterRoleBinding
	CertSecrets                                              *corev1.Secret
	ConfigLoggingCM                                          *corev1.ConfigMap
	CoreCR                                                   *rbacv1.ClusterRole
	CoreCRB                                                  *rbacv1.ClusterRoleBinding
	DefaultingWebhookK8SAwsMutatingwebhookconfigurations     *admissionregistrationv1.MutatingWebhookConfiguration
	DefaultingWebhookShMutatingwebhookconfigurations         *admissionregistrationv1.MutatingWebhookConfiguration
	Deploy                                                   *appsv1.Deployment
	DnsRB                                                    *rbacv1.RoleBinding
	DnsRole                                                  *rbacv1.Role
	GlobalSettingsCM                                         *corev1.ConfigMap
	PDB                                                      *policyv1.PodDisruptionBudget
	RB                                                       *rbacv1.RoleBinding
	Role                                                     *rbacv1.Role
	SA                                                       *corev1.ServiceAccount
	SVC                                                      *corev1.Service
	ValidationWebhookConfigShValidatingwebhookconfigurations *admissionregistrationv1.ValidatingWebhookConfiguration
	ValidationWebhookK8SAwsValidatingwebhookconfigurations   *admissionregistrationv1.ValidatingWebhookConfiguration
	ValidationWebhookShValidatingwebhookconfigurations       *admissionregistrationv1.ValidatingWebhookConfiguration
}

// New creates a new Karpenter
func New() *Karpenter {
	return &Karpenter{
		AdminCR:         AdminCR,
		CR:              CR,
		CRB:             CRB,
		CertSecrets:     CertSecrets,
		ConfigLoggingCM: ConfigLoggingCM,
		CoreCR:          CoreCR,
		CoreCRB:         CoreCRB,
		DefaultingWebhookK8SAwsMutatingwebhookconfigurations: DefaultingWebhookK8SAwsMutatingwebhookconfigurations,
		DefaultingWebhookShMutatingwebhookconfigurations:     DefaultingWebhookShMutatingwebhookconfigurations,
		Deploy:           Deploy,
		DnsRB:            DnsRB,
		DnsRole:          DnsRole,
		GlobalSettingsCM: GlobalSettingsCM,
		PDB:              PDB,
		RB:               RB,
		Role:             Role,
		SA:               SA,
		SVC:              SVC,
		ValidationWebhookConfigShValidatingwebhookconfigurations: ValidationWebhookConfigShValidatingwebhookconfigurations,
		ValidationWebhookK8SAwsValidatingwebhookconfigurations:   ValidationWebhookK8SAwsValidatingwebhookconfigurations,
		ValidationWebhookShValidatingwebhookconfigurations:       ValidationWebhookShValidatingwebhookconfigurations}
}

// Apply applies the kubernetes objects to the cluster
func (a *Karpenter) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *Karpenter) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(km, kube.WithExportWriter(stdin), kube.WithExportAsSingleFile("stdin")); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}
